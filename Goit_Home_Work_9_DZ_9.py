# ===================  Home work 9 ========================

# =================    Функції (декоратори, замикання)  =================

    # 1. Функція як об'єкт першого класу
    # 2. Області видимості (LEGB)
    # 3. ЗАМИКАННЯ
    # 4.  КАРРУВАННЯ
    # 5. Декоратори
    # 6. Ітератори/генератори (ключове слово yield)
    # 7. Лямбда-функції (анонімні функції)
    # 8. MAP
    # 9. Filter

# ================================================================


# ================================ Звдання 1 / Task 1 ======================================

# ================================ Функція як обєкт першого класу . Виклик функції з іншої функції. =================================

# Wikipedia

# У програмуванні функція, яка приймає як аргументи інші функції або повертає іншу функцію в якості результату.
# Основна ідея у тому, що функції мають той самий статус, як і інші об'єкти даних.

# Оскільки у Python функції – це об'єкти першого класу, то вони є HOF (High Order Functions), 
# ця властивість активно використовується для розробки програмного забезпечення.

# На практиці це означає, що ми можемо працювати з функціями у Python точно так, як з будь-якими іншими типами даних:

# можемо створювати змінні і записувати в них функції;

#   def func(x, y):
#       return x + y

#   func_alias = func
#   result = func_alias(2, 3)
#   print(result)  # 5
# можемо передавати функцію як аргументи для інших функцій;

#   def sum_func(x, y):
#       return x + y

#   def subtraction_func(x, y):
#       return x - y

#   def tricky_func(x, y, func):
#       return func(x, y)

#   sum_result = tricky_func(2, 3, sum_func)
#   min_result = tricky_func(2, 3, subtraction_func)

#   print(sum_result)  # 5
#   print(min_result)  # -1
# можемо повертати з функції інші функції.

#   def sum_func(x, y):
#       return x + y

#   def subtraction_func(x, y):
#       return x - y

#   def get_operator(operator):
#       if operator == '+':
#           return sum_func
#       elif operator == '-':
#           return subtraction_func
#       else:
#           print('Unknown operator')

#   sum_action_function = get_operator("+")
#   print(sum_action_function(2, 3))    # 5

#   sub_action_function = get_operator("-")
#   print(sub_action_function(2, 3))    # -1
# Таким чином з функціями у Python можна працювати так само, як і з будь-якими іншими об'єктами.


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Повернемося до завдання про систему оцінок в університеті, які мають такий вигляд:

# Оцінка	Бали	Оцінка ECTS	    Пояснення

# 1	    0-34	    F	       Unsatisfactorily
# 2	    35-59	    FX	       Unsatisfactorily
# 3	    60-66	    E	       Enough
# 3	    67-74	    D	       Satisfactorily
# 4	    75-89	    C	       Good
# 5	    90-95	    В	       Very good
# 5	    96-100	    A	       Perfectly

# Минулого разу ми реалізували дві функції. Перша - get_grade, 
# приймає ключ в оцінці ECTS і повертає відповідну п'ятибальну оцінку (перший стовпчик таблиці).
# Друга - get_description, теж приймає ключ у оцінки ECTS, але повертає пояснення оцінки у текстовому форматі (останній стовпчик таблиці).
# На неіснуючий ключ функції повинні повертати значення None.

# Реалізуйте функцію вищого порядку get_student_grade, яка приймає параметр option. Якщо він дорівнює значенням "grade", 
# то функція повертає функцію get_grade, а якщо його значення дорівнює "description", то повертає функцію get_description. 
# Якщо параметр за значенням не співпав із заданими, то функція get_student_grade повинна повертати значення None.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def get_grade(key):
#     ''' Функція за ключем *key , повертає значення з словника *grade.\
#         якщо вказати невіриний ключ поверне заначення *None.'''
# 
#     grade = {"A": 5, "B": 5, "C": 4, "D": 3, "E": 3, "FX": 2, "F": 1}
#     return grade.get(key, None)


# def get_description(key):
#     ''' Функція за ключем *key , повертає значення з словника *description.\
#         якщо вказати невіриний ключ поверне заначення *None.'''
# 
#     description = {
#         "A": "Perfectly",
#         "B": "Very good",
#         "C": "Good",
#         "D": "Satisfactorily",
#         "E": "Enough",
#         "FX": "Unsatisfactorily",
#         "F": "Unsatisfactorily",
#     }
#     return description.get(key, None)

# def get_student_grade(option):
#     '''Функція приймає один аргумент *option, і якщо він містить змінні *get_description або *get_grade, \
#     то повертає відповідні функції за іменем оголошених функції після  оператора def *імя_функції(*аргументи_або_без_аргументів).\
#         Якщо аргументи, в оголошених функціях, відсутні в тілі коду обо повертати з основної функції тільки імя додаькової функції,\
#               то повертає клас *<function *імя_функції at *область_памяті_OS> на який вказує *optionю \
#                 Якщо аргумент оголошений в коді, і, в основновній функції повертає фінкцію, а не тільки їмя, то поверне результат отриманий з додаткової функції '''
 
#     if option == get_description: # Перевірка чи *option = get_description
#         return get_description    # якщо виконалась умова *if option == get_description - поверне *<function get_description at 0x000001B3B7327F60>
    
#     elif option == get_grade:     # Перевірка чи *option = get_grade
#         return get_grade          # якщо виконалась умова *elif option == get_grade - поверне *<function get_grade at 0x000001CB0CBF8A40>
#     else:
#        return None                # Поверне *None якщо жодна з попередніх умов невиконається .

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# # key = "A" # Тестове значення.    
# # option = get_description # Тестове значення  # *<function get_description at 0x000001B3B7327F60>
# # option = get_grade  # Тестове значення  #  *<function get_grade at 0x000001CB0CBF8A40>
# # option = "asd"  # Тестове значення # *None

# # print(get_student_grade(option)) 

# +++++++++++++++++++++++ Для автоперевіки Код буде наступний +++++++++++++++++

# def get_student_grade(option):
    
#    if option == "description":
       
#        return get_description
   
#    elif option == "grade": 
#        return get_grade
#    else:
#        return None
   
# ================================ Звдання 2 / Task 2 ======================================

# ================================  Область видимості . Global Scope , Local Scope  =================================

# Область видимості — це область у програмі (коді), в межах якої ви можете звернутися по імені до вмісту змінної 
# (або як ми вже з'ясували функції). У Python можна виділити дві великі області видимості:

# глобальну (Global Scope). Все, що оголошено в цій області, буде доступне в будь-якій частині вашого додатку;
# локальну (Local Scope). Все, що оголошено в локальній області видимості, буде доступно тільки всередині неї.
# Глобальна область видимості лише одна і в ній міститься все, що ви оголосили на рівні модулю (змінні, функції, інші модулі і т.п).

# Локальна область видимості створюється, коли інтерпретатор потрапляє усередину функції.

# SOME_VAR = 3


# def func(x):
#     SOME_VAR = x
#     print(SOME_VAR)


# def procedure()
#     print(SOME_VAR)


# procedure()  # 3
# func(5)  # 5
# print(SOME_VAR)  # 3
# Давайте розберемо на цьому прикладі, як працюють області видимості. Змінна SOME_VAR оголошена на рівні модулю у глобальній області видимості 
# (так само, як і функції func та procedure).

# Коли ми викликаємо procedure усередині неї створюється локальна зона видимості. 
# У локальній для procedure області видимості немає SOME_VAR, і коли ми виконуємо вираз print(SOME_VAR), 
# Python спочатку шукає SOME_VAR у локальній області видимості, не знаходить і йде шукати у глобальній, де і знаходить SOME_VAR рівне 3.

# Коли ми викликаємо func, усередині неї створюється локальна зона видимості.
# В цій локальній області ми створюємо змінну SOME_VAR і привласнюємо їй значення 5.
# У цей момент глобальна зона видимості ніяк не змінюється, нова SOME_VAR існує тільки всередині func. 
# На підтвердження цього ми виконуємо print(SOME_VAR) на рівні модуля і отримуємо 3, що каже про те, 
# що всередині func існувала своя окрема змінна з ім'ям SOME_VAR.

# Щоб краще розуміти, що таке зона видимості, слід зрозуміти як працює їх механіка.

# У Python області видимості реалізовані як словники, в яких ім'я змінної або функції (рядок) — це ключ, 
# а сам об'єкт — це значення в цьому словнику.

# Таким чином, коли ви у коді виконали x = 2, в словнику простору імен (той же, що і область видимості) додалася пара: 'x': 2. 
# І коли десь далі вам потрібно отримати значення x із цього словника, буде взято значення 2, знайдене по ключу 'x'.

# Коли створюється нова зона видимості (простір імен), то насправді створюється новий подібний словник 
# (старий нікуди не дівається звичайно ж).

# Тут можна зробити важливий висновок, у вас в коді може одночасно існувати декілька просторів імен, які не взаємодіють один з одним. 
# Це у свою чергу означає, що пошук об'єктів по імені повинен відбуватися за якимсь правилом.

# У Python правила пошуку імен дуже прості:

# спочатку пошук йде в локальному просторі імен (LOCAL);
# якщо не знайдено в локальному, то в локальному на наступному рівні (ENCLOSED) і так далі, поки локальні не закінчаться;
# далі буде перевірено глобальний (GLOBAL) простір імен (рівень модуля);
# і в останню чергу простір вбудованих імен (BUILT INS) — це ключові слова і функції, що є частиною мови Python.
# Якщо ніде не знайдено сутності з таким ім'ям, то отримаємо виключення.

# Це правило можна запам'ятати по його акроніму: (LOCAL, ENCLOSED, GLOBAL, BUILT INS).

# У цьому правилі ми не розглянули, що таке ENCLOSED.

# GLOBAL_SCOPE_VAR = 1

# def func():
#     enclosed_scope_var = 2

#     def inner():
#         inner_var = 3
# В цьому коді всередині функції func оголошена функція inner. 
# Для функції func enclosed_scope_var та inner — знаходиться в LOCAL області видимості. 
# Для функції inner змінна inner_var буде в її локальній області видимості, 
# а вже enclosed_scope_var буде в ENCLOSED, в локальному просторі, але на рівень вище.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++


# Реалізуйте функцію get_discount_price_customer для розрахунку ціни на товар інтернет-магазину з урахуванням знижки клієнта.

# Функція приймає два параметри:

# price — ціна продукту
# customer — словник з даними клієнта такого виду: {"name": "Dima"} або {"name": "Boris", "discount": 0.15}
# Ви маєте глобальну змінну DEFAULT_DISCOUNT, яка визначає знижку для клієнта, якщо у нього немає поля discount.

# Функція get_discount_price_customer має повертати нову ціну товару для клієнта.

# Нагадаємо, що дисконт discount - це дробове число від 0 до 1. І ми під знижкою розуміємо коефіцієнт, який визначає величину ціни. 
# І на цю величину ми знижуємо підсумкову ціну товару: price = price * (1 - discount).

# +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# DEFAULT_DISCOUNT = 0.05 # Глобальна константа( зміна )


# def get_discount_price_customer(price, customer):
#     '''Функція яка приймає два аргумента, 
#      *price(тип *int) і *customer(тип *dict).
#      Повертає *product_price(тип *float) - вартість товару з врахуванням знижки'''
    
#     disc = customer.get("discount")  # *customer.get("discount") - повертаємо в *disc, значення з *customer, за ключем *"discount" методом -*.get(*key)
#                                      # Метод *імя_словника.get("*ключ") - за вказаним ключем повертає з словника відповідне значення. 
#                                      # Якщо вказаного ключа не має в словнику то повертає *None 
    
#     if disc != None:                        # Умова для перевірки за значеням  *disc .Якщо значення не *None, значить в поточному словнику є ключ *"discount" 
#                                             # Тобто в даного користувача є персональна знижка . Варість розраховуємо з врахуванням пересональної знижки. 
#         product_price = price * (1-disc)    # Формула розрахунку вартості товару з урахуванням персональної знижки. *product_price = 100*(1-0.15)
#         return product_price                # Тестове повернення: *product_price = 85
    
#     else:                                   # Якщо умова не виконалась, тобто в *customer не має ключа *"discount". Розраховуємо вартсть товару з врахуванням загальної знижки *DEFAULT_DISCOUNT
#         product_price = price * (1-DEFAULT_DISCOUNT) # Формула розрахунку вартості товару з урахуванням загальної знижки. *product_price = 100*(1-0.05)
#         return product_price                # # Тестове повернення: *product_price = 95
    
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# price = 100  # Тестове значення

# customer = {"name": "Dima"}  # Тестове занчення що немістить ключа *"discount"

# customer = {"name": "Boris", "discount": 0.15} # # Тестове занчення що містить ключ *"discount"

# print(get_discount_price_customer(price, customer)) # Принтимо значення яке поверне функція *get_discount_price_customer(price, customer)


# ================================ Звдання 3 / Task 3 ======================================

# ================================  Концепція замикання . ============================== 
#===========   функцію caching_fibonacci(), яка матиме кеш із попередньо обчисленими значеннями чисел Фібоначі =================================

# Особливість існування вкладених локальних просторів імен і той факт, що вони створюються динамічно,
# дає можливість використати механізм замикань у Python.

# Найпростіше це пояснити на прикладі:

# def adder(val):
#     def inner(x):
#         return x + val
#     return inner


# two_adder = adder(2)
# print(two_adder(3)) # 5
# print(two_adder(5)) # 7

# three_adder = adder(3)
# print(three_adder(5))   # 8
# print(three_adder(-3))  # 0

# id(two_adder) == id(three_adder)    # False
# В даному прикладі ми створили функцію adder, яка повертає внутрішню функцію inner. 
# Коли інтерпретатор заходить в adder (наприклад у виразі two_adder = adder(2)) створюється новий локальний простір імен в adder, 
# де створюється функція inner, яка і повертається з функції. Що не очевидно, так це те, що новостворена inner, коли її викликають,
# буде використовувати те значення val, яке було в adder на момент її створення.

# Коли ми виконали two_adder = adder(2), в two_adder записали функцію inner, яка буде додавати 2 до x. 
# А коли виконали three_adder = adder(3), то в three_adder записали inner, яка буде завжди додавати 3 до x.

# two_adder та three_adder — це дві різні функції, про що каже результат перевірки їх ідентифікаторів 
# (вираз id(two_adder) == id(three_adder)).
  
# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Концепцію замикання може добре пояснити приклад кешування значень функції.

# Підсумкове завдання модуля 3 було — рекурсивне обчислення чисел Фібоначчі.

# Ряд Фібоначчі - це послідовність чисел виду: 0, 1, 1, 2, 3, 5, 8, ..., 
# де кожне наступне число послідовності виходить додаванням двох попередніх членів ряду.

# У загальному вигляді для обчислення n-го члена ряду Фібоначчі потрібно вирахувати вираз: Fn = Fn-1 + Fn-2.

# Це завдання можна вирішити рекурсивно, викликаючи функцію, що обчислює числа послідовності доти, 
# доки виклик не сягне членів ряду менше n = 1, де послідовність задана.

# Створіть функцію caching_fibonacci(), яка матиме кеш із попередньо обчисленими значеннями чисел Фібоначі.
# Усередині вона містить функцію fibonacci(n), яка безпосередньо і обчислюватиме саме число Фібоначчі. 
# Функція caching_fibonacci() повертає функцію fibonacci

# Якщо число Фібоначчі зберігається у словнику cache, то функція fibonacci повертає число з кеша. 
# Якщо його немає у кеші, то ми обчислюємо число і поміщаємо його в кеш, і повертаємо з функції fibonacci.

# +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def caching_fibonacci():
#     '''Функція (без аргументів), яка викликає і повертає вбудовану функцію *fibonacci(n,cache = {}), за її іменем *fibonacci \
#          Виклик ,вбудованої функції за іменем, дозволяє присвоювати її будь якій змінній в тілі програми в Глобальному просторі коду,\
#          з довільним іменем зміної аргументу. Тобто значення зміної *n ,в вбудованій функції *fibonacci(n,cache = {}),\
#          *НАПЕРЕД НЕ ВИЗНАЧЕНЕ* в локльному просторі і може бути довільним. \
#            в описі вбудованої функції *def fibonacci(n,cache = {}) - міститься код, який описує, що треба буде зробити з *n, якщо його значення буде передано в функцію з Глобального простору.\
#          Тобто передача значення аргумента *n в *fibonacci(n,cache = {}) з глобального простору , відбувається за наступною схемою:
#          *імя_зміної = *функція_що_повертає_вбудовану_функцію_за_її_іменем. 
#          *імя_зміної(*імя_аргумету_що_передається_в_вбудовану_функію_як_аргумент_n)
         
#          *Приклад для нашого коду:  *call_local_func_fibonacci = caching_fibonacci() # Присвоюємо *call_local_func_fibonacci локальний простір з *сaching_fibonacci(), # *call_local_func_fibonacci = <function caching_fibonacci.<locals>.fibonacci at 0x000001983E2C7F60>
#                                                                                     #  що містить повернутий локальний простір з функції *fibonacci .                  # *fibonacci = <function caching_fibonacci.<locals>.fibonacci at 0x000002A455227F60>
#                                                                                     #  
#                                     *call_local_func_fibonacci(num_fibon) # Де *call_local_func_fibonacci- виклик функції *caching_fibonacci(),
#                                                                           # а *num_fibon - конкертне значення, з Глобального простору, яке передається локальній змінній *n з вбудованої функції *fibonacci(n,cache = {}) для обрахунку.
         
#          *Примітка : Глобальноий простір коду(*Global Scope) - тіло коду поза описом функції оператором *def...\
#                      Локальний простір коду(*Local Scope) - тіло коду в середені функції описаної оператором *def...\
#                                                 '''
         
#     def fibonacci(n, cache = {}):
#         '''Вбудована рекурсивна функція, яка приймає два аргументи:
#                      # *n(тип *int)- обовязковий (передається з глобального простору, читай опис функ *caching_fibonacci(),
#                      # *cache(тип *dict) - необовязковий (він є необовязковий бо відразу оголошено його початкове значення *{}. в локалному просторі буде набувати динамічного значення,  оскльки будемо його постійно формувати і рекурсивно повертати з функції, до поки не виконається умова *if fibon_new is not None  )
                     
#                      # Повертає значення переданого в *n номера, числа Фібончі. # Приклад : *n = 9 , поверне зачення *34, *n = 4 , поверне зачення *3.
#         # Опис алгоритму повернення : # Як тільки умова виконається *if fibon_new is not None: - виконається , відбудиться вихід з функції , а отже і припинеться рекурсія. і в *cache буде міститись згенерований словник з потрібним нам значенням .
#                                       # значення на якому виконалось умова виходу з рекурісії , отримає ключ з поточним іменем *n в динамічно сформованому словнику *cache .
#                                       # за поточним  значенням ключа *n повертаємо з функції його значення з динамічно створеного поточного словника *cache
#                                       # Передане значення повернеться в глобалний простір як результат виконання функції за викликом *call_local_func_fibonacci(num_fibon) - для нашого прикладу.
#                                       # Примітка : Поточні значення *n і *cache будуть міститися в локальному просторі *fibonacci '''
       
#         fibon_new = cache.get(n) # За поточним значенням ключа *n, повертаємо відповідне значення з словника *cache. # Початкове поточне значення передається з глобального простору через зміну *num_fibon 
#                                  # Для нашого прикладу *num_fibon = 9 отже в *n початково дорівнює *9.  
#                                  # Осікільки початкове значення *cache = {}, оголошене як аргумент функції *fibonacci(n, cache = {}), дорівнює пустому словнику *{},
#                                  # То такого ключа небуде в *cache і застосований метод  *cache.get(n) поверне значення *None на поточній ітерації функції. 
#                                  # Примітка : # *cache.get(n) буде повертати *None до тих пір, поки в *cache не згенерується відповідний, переданий *n ключ, з відповідним значенням числа Фібоначі.
#                                               # а отже буде відбуватись подальший код в тілі функції, оскільки подальший код буде містити рекуривний виклик поточної функції, 
#                                               # то він буде виконуватись доти, поки n не стане 0 , зменшенням *n на одиницю на кожному рекурсивному виклику. # *n = n -1
       
#         #print(f'fibon_new={fibon_new}') # тестовий принт для контролю значень.
#         if fibon_new is not None : return fibon_new  # Запис умови для виходу з фукції *fibonacci(n, cache = {}) і повернення з функції кінцевого результату  *fibon_new.
#                                                      # Примітка : Такий запис рахується більш бажаним і елегантінішим  рівноціному : 
#                                                                                                                        # *if fibon_new != None :
#                                                                                                                        #     return fibon_new  

#         else :  # Допоки умова *if fibon_new is not None невиконується будемо генерувати нові значення в *cache  через рекурсивний виклик *cache[f'{n}'] = fibonacci(n-1) + fibonacci(n-2)
            
#             if  n==0:   # Точка виходу з рекурсії .
#                     return 0
#             elif n==1 or  n==2 : # У мова досягнення точки виходу з рекурсії. Оскільки перше і друге число Фібоначі є одинаковими та дорівнює 1 # Примітка : пояснення для себе ))).
#                     return 1
#             else:
#                 cache[f'{n}'] = fibonacci(n-1) + fibonacci(n-2)  # Поки не виконаються умови *if  n==0: або *elif n==1 or  n==2 : ,точки виходу з рекурсії.
#                                                                  # Будемо формувати наш словник *cache[f'{n}'] = fibonacci(n-1) + fibonacci(n-2) .
#                                                                  # Де *[f'{n}'] - поточний ключ(на перошому кроці буде сформовано той, що і переданий у функцію з зміної *n = num_fibon , на наступному *(n - 1) , 
#                                                                  # і так поки не стане *n = 3, *n = 3 це точка виходу з рекурсивного виклику , описана в умовами вище).
#                                                                  # Як тільки рекурсивний виклик досягне точки виходу , то рекурсія почне схлопуватись в зворотньому порядку 
#                                                                  # і на виході поверне наш наш динамічно створений *cache на останю ітерацію функції *fibonacci(n, cache = {}),
#                                                                  # тоді *fibon_new = cache.get(n) поерне в *fibon_new відповідне значення, а не *None (осклільки наш *cache буде вже містити потрібну пару ключа і значення )
#                                                                  # тоді і виконається умова *if fibon_new is not None : return fibon_new 
#                                                                  # відповідно *call_local_func_fibonacci(num_fibon) , поверне відповідне число Фбоначі яке відповідає номеру переданому з *num_fibon 
                                                                 
#                 #print(cache) # тестовий принт для контролю значень
#                 #print(n)    # тестовий принт для контролю значень
#                 #print (cache[f'{n}']) #тестовий принт для контролю значень 
                
#                 return cache[f'{n}']  # Рекурсивне повернення в функцію поточного значення. за поточним ключем *[f'{n}'] для формування динамічного словника *cache
            
#     #print(fibonacci)
#     return fibonacci # Повернення з основної функції *caching_fibonacci() імя вбудованої(*fibonacci)- імя містить локальний простір функції fibonacci(n, cache = {}) #  . 
#                      # для того щоб забезпечити передачу, з глобального простору, значення *n з зміної *num_fibon ,
#                      # у вбудовану функцію, в якій *n наперед не оголошено і відповіддний обрахунок та повернення відповідного значення числа Фібоначі для *num_fibon
#                      # *fibonacci= <function caching_fibonacci.<locals>.fibonacci at 0x000002316BC27F60 - локальний простір *fibonacci(n, cache = {})

# # ++++++++++++++++++++++++++++++++++++++++++++++++++ Тестові значення і виклик функції (не потрібний для автоперевірки.) ++++++++++++++++++++++

# call_local_func_fibonacci = caching_fibonacci() # В *call_local_func_fibonacci повертаємо локальний простір *caching_fibonacci() з якого повертаємо імя вібудованої функції *fibonacci

# num_fibon = 9 # тестове значення (вказує на номер чила Фібоначі значення якого потрібно обчислити і повернут)

# #print(call_local_func_fibonacci) # Тестовий прінт.
# print(call_local_func_fibonacci(num_fibon)) # тестовий прінт в якому і будемо робити виклик *call_local_func_fibonacci(num_fibon) з аргументом *num_fibon і одночас виводом на екран відповідого значення.
#                                             # Для *num_fibon = 9 виведе 34 .

# ================================ Звдання 4 / Task 4 ======================================

# ================================  КАРРУВАННЯ . ============================== 

# Каррування — це перетворення функції від багатьох аргументів в набір функцій, кожна з яких є функцією від одного аргументу. 
# Ми можемо передати частину аргументів у функцію і отримати назад функцію, очікуючу інші аргументи.

# Наприклад, для додатка калькулятора ми можемо створити функцію, яка буде приймати операнди і оператор:

# def handle_operation(x, y, operator):
#     if operator == '-':
#         return x - y
#     elif operator == '+':
#         return x + y


# handle_operation(2, 3, '+')  # 5
# handle_operation(2, 3, '-')  # -1
# Це рішення страждає тим, що додавання нових і нових математичних операторів постійно ускладнюватиме конструкцію if ... elif ....

# Щоб уникнути цього, ми можемо скористатися карруванням:

# def sum_func(x, y):
#     return x + y


# def sub_func(x, y):
#     return x - y


# OPERATIONS = {
#     '-': sub_func,
#     '+': sum_func
# }


# def get_handler(operator):
#     return OPERATIONS[operator]


# handler = get_handler('-')
# handler(2, 3)           # -1

# get_handler('+')(2, 3)  # 5
# При такому підході get_handler повертатиме нам потрібну функцію двох аргументів із словника з функціями OPERATIONS. 
# Це швидший і елегантніший спосіб уникнути величезних if ... elif ... конструкцій. Крім того, 
# так ви можете зменшувати кількість аргументів, які передаєте у функцію до прийнятної кількості (не більше двох), 
# створюючи "на льоту" нові функції, які вже "знають" про передані аргументи. Як ми робили з two_adder та three_adder в минулому

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Повернемося до завдання розрахунку ціни з урахуванням дисконту та розберемо підхід із позиції карування.
# Створіть функцію discount_price(discount), яка визначатиме в собі та повертатиме функцію розрахунку реальної ціни з урахуванням знижки.

# Виклик функції discount_price(discount) поверне функцію, яка розраховує ціну на товар зі знижкою, що дорівнює discount .

# ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# Наприклад:

# cost_15 = discount_price(0.15)
# cost_10 = discount_price(0.10)
# cost_05 = discount_price(0.05)

# price = 100
# print(cost_15(price))
# print(cost_10(price))
# print(cost_05(price))
# Повинен вивести:

# 85.0
# 90.0
# 95.0

# +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def discount_price(discount):  
#     '''Основна функція, яка приймає один аргумент *discount, який передає в локальний простір вбудованої функцію *discount_price(pri),
#     і повертає локальний простір функції *discount_price(pri) за її іменем. Для того щоб передати аргумент *price з глобального простору коду для обрахунків ,
#     та повернення , відповідно обчисленого, значення локальної зміної *product_price в глобальний простір.  '''

#     def discount_price(pri) :
#         ''' Вбудована функція яка отримує один аргумент *pri ( який буде містити глобальне значення зміної *price з глобального простору)
#          і повертає розраховану вартість товару згідно формули і переданих даних як простору основної фінкції *discount_price(discount) значення *discount
#           так і з глобального простору значення *price '''
        
#         product_price = pri * (1 - discount) # Формула розрахунку вартості товару враховуючи знижку.
        
#         return product_price          # Повернення результату *product_price, з вбудовано функції *discount_price(pri) 

#     return discount_price # Повернення імені вбудованої  вбудовано функції *discount_price(pri) з основної функ. *discount_price(discount) 
    
# # +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++    

# cost_15 = discount_price(0.15) # Тестове значення , де аргумент *discount явно передаєься у фінкцію *discount_price, *discount = 0.15, 
#                                # а локальний простір *discount_price(discount) повертається у зміну *cost_15.
#                                # це і є принцип Каррування . тобто *cost_15 буде містити локальний_простір *discount_price з вже переданим значенням **discount
#                                # При виклику *cost_15, значення *discount= 0.15 вже буде міститись в локальному простор

# cost_10 = discount_price(0.10) # Тестове значення , де аргумент *discount явно передаєься у фінкцію *discount_price, *discount = 0.10, 
#                                # а локальний простір *discount_price(discount) повертається у зміну *cost_10
#                                # це і є принцип Каррування . тобто *cost_10 буде містити локальний_простір *discount_price з вже переданим значенням **discount
#                                # При виклику *cost_10, значення *discount= 0.10 вже буде міститись в локальному простор

# cost_05 = discount_price(0.05) #  Тестове значення , де аргумент *discount явно передаєься у фінкцію *discount_price, *discount = 0.05, 
#                                # а локальний простір *discount_price(discount) повертається у зміну *cost_05
#                                # це і є принцип Каррування . тобто *cost_05 буде містити локальний_простір *discount_price з вже переданим значенням **discount
#                                # При виклику *cost_05, значення *discount= 0.05 вже буде міститись в локальному простор

# price = 100                    # тестове значення для розрахунку відповідної вартості товару враховуючи відповідну знижку яка міститься в локальному просторі карпованих фінкцій (cost_15,cost_10,cost_05) - відповідно. 
# print(cost_15(price)) # Принтемо результат повернений вартості товару , відповідно до знижки .# 85.0
# print(cost_10(price)) # Принтемо результат повернений вартості товару , відповідно до знижки .# 90.0
# print(cost_05(price)) # Принтемо результат повернений вартості товару , відповідно до знижки .# 95.0

# ================================ Звдання 5 / Task 5 ======================================

# ================================  Декоратор . ============================== 

# Є такий шаблон проектування — Декоратор. Цей шаблон полягає в тому, щоб розширювати існуючий функціонал, 
# не вносячи змін в код цього самого функціоналу.

# Наприклад, у нас є якась дуже складна і важлива функція complicated:

# def complicated(x, y):
#     return x / y
# І ми не хочемо міняти її код з якоїсь причини. Але нам потрібно додати логірування до цієї функції, 
# виводити в консоль кожного разу, коли вона викликається, з якими аргументами її викликали і що вона повернула в результаті.

# Пам'ятаючи про те, що функція — це об'єкт першого класу, можна зробити щось подібне:

# def complicated(x, y):
#     return x / y


# def logged_func(func):
#     def inner(x, y):
#         print(f'called with {x}, {y}')
#         result = func(x, y)
#         print(f'result: {result}')
#         return result
#     return inner


# complicated = logged_func(complicated)
# Тепер, викликаючи complicated, ми побачимо у консолі, з якими аргументами її викликали і що вона повернула.
# При цьому, код самої complicated ніяк не змінився і спосіб роботи з нею також.

# Проте такий код не занадто легкий для читання і досить об'ємний.
# Крім того, в коді легко пропустити рядок complicated = logged_func(complicated) і не занадто просто зрозуміти, 
# звідки виходитиме доданий до complicated функціонал.

# Щоб спростити застосування цього шаблону проектування, в Python є спеціальний синтаксис декоратора. 
# Точно той же код, який робить в точності теж саме, можна записати у виді:

# def logged_func(func):
#     def inner(x, y):
#         print(f'called with {x}, {y}')
#         result = func(x, y)
#         print(f'result: {result}')
#         return result
#     return inner


# @logged_func
# def complicated(x, y):
#     return x / y
# Тепер у коді явно видно, що complicated була задекорирована logged_func у тому ж місці, де complicated була оголошена.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# У модулі 5 ми написали функцію sanitize_phone_number для нормалізації рядка з телефонним номером. Нагадаємо, що при отриманні рядків

    # "    +38(050)123-32-34",
    # "     0503451234",
    # "(050)8889900",
    # "38050-111-22-22",
    # "38050 111 22 11   ",
# Ми отримували наступний вивід:

# 380501233234
# 0503451234
# 0508889900
# 380501112222
# 380501112211
# Уявіть, що в іншому місці програми у нас виникла вимога зробити висновок у форматі

# +380501233234
# +380503451234
# +380508889900
# +380501112222
# +380501112211
# І тут ідеально підійде створення декоратора для функції sanitize_phone_number. 
# Декоратор повинен додавати для коротких номерів префікс +38, а для повного міжнародного номера (з 12 символом) - тільки знак +. 
# Реалізуйте декоратор format_phone_number для функції sanitize_phone_number з необхідним функціоналом.

# +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def format_phone_number(func):
#     ''' Функція декоратор для функції *sanitize_phone_number(phone) 
#         Тобто виводить резуьтат, повернутий з *sanitize_phone_number(phone), згідно опису в вбудованій функції *inner(phone)
#         де саме аргумент *func містить локальний простір функції яку декоруємо ,а не імя функції як при карруванні чи замиканні '''
    
#     def inner(phone):
#         '''Вбудована функція яка семе буде приводити до одного вигляду різні дані передані з *sanitize_phone_number(phone) '''
        
#         decorat_sanitize_phone_number = func # передаєм локальний простір функції *sanitize_phone_number(phone), який міститься у аргументі *func змінній  *decorat_sanitize_phone_number

#         #print(decorat_sanitize_phone_number(phone)) # Тестовий прінт . 

#         if len(decorat_sanitize_phone_number(phone)) == 10: # Викликаємо локальний простір функції переданої в d*ecorat_sanitize_phone_number з аргументом *phone 
#                                                             # аргумент *phone передасться в функцію *stize_phone_number(phone) і з функії після опрацювання повернеться відповідний результат
#                                                             # повернyний результат  перевіряємо на довжину (довжина буде номером телефону), повернутого з функції *sanitize_phone_number(phone).
#                                                             # якщо довжина номера складається з 10 цифр то потрібно добавити +38
#                                                             # або якщо довжина дорівнює 12 смиволів, то додаємо тільки знак +

#            return f'+38{decorat_sanitize_phone_number(phone)}' # якщо довжина ноера 10 цифр то потрібно спереді дописати *+38 . Робимо це задопомогою вбудованої функції f-рядка.
#                                                                # f-рядок приймає рядок(тип *str) і повертає рядок(*str), де в лапках записані символи передаються без змін а аргументи записуються в фігурних дужках {*аргументи}.
#                                                                # повернуті аргументи приводяться до типу (*str)
#                                                                # Приклад : '+38{decorat_sanitize_phone_number(phone)} для поточного знчення *phone = 0503451234 поверне +380503451234

#         elif len(decorat_sanitize_phone_number(phone)) == 12: # Той самий опис щой для попердньої умови , тільки цього разу перевіряємо чи довжина поернутого рдка дорівнює 12 символів .
#                                                               # якщо так то потрібно дописати тільки знак + спереді.
            
            
#             return f'+{decorat_sanitize_phone_number(phone)}' # повертаємо сформований результат  f'+{decorat_sanitize_phone_number(phone)}' для поточного значення *phone = 380501112211 , поверне +380501112211

#         else :
#            return print(f'вказаний  не мобільний номер')  # Повертаємо повідомлення якщо жодна з вище вказаних умов не виконалась.
#     return inner # повертаємо назву вбудованої функції *inner(phone). Виконуємо зациклення .
#                  # Зациклювання робимо для того щоб передати локальний простір вбудованої функції у функцію вищого рівння.

# @format_phone_number  # Спеціальний запис *@format_phone_number - який вказує який декоратор буде застосований до функції з описом нижче *def sanitize_phone_number(phone)
#                       # @format_phone_number - сладається з смивола @ і імені функції декоратора. *@імя_декоратора.
#                       # Приймає  повернуте значення з *sanitize_phone_number(phone) і повертає з *sanitize_phone_number(phone) вже відповідно задекороване значення згіно умов описаних в декораторі.

# def sanitize_phone_number(phone):
#     '''Основна функція до якої застосовуємо декоратор *@format_phone_number . Приймає рядок (*тип str), повертає новий рядок вже без 
#     пробілів на початку і вкінці рядка , без знаку '+' на початку рядка , без знаків '(',')','-' і ' ' в середині рядка. 
#     *.strip() - видаляє всі пробіли на початку і вкінці рядка (*в середені рядка пробіли залишаються без змін)
#     *.removeprefix("+") - видаляє смивол "+" на початку рядка
#     *.replace("(", "") - заміняє в рядку всі смивволи *"(" на пустий смивол *"" (те саме що видалити смивол)
#       всі інші  *.replace(*шаблон, *новий_шаблон) - виконують те саме що й і вище описаний тільки заміна відбувається інших сиволів.
#         а саме *')','-' на пустий смивол *"" .''' 
#     new_phone = (
#         phone.strip()
#             .removeprefix("+")
#             .replace("(", "")
#             .replace(")", "")
#             .replace("-", "")
#             .replace(" ", "")
#     )
#     return new_phone  # Повертає відповідно за декороване значення , згідно опису в декораторі *@format_phone_number --> *sanitize_phone_number(phone)  --> *format_phone_number(func) -->  *inner(phone)

# # +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++ 

# phone = '    +38(050)123-32-34' # тестові значення
# phone = '     0503451234'
# phone = '(050)8889900'
# phone = '38050-111-22-22'
# phone = '38050 111 22 11   '

# print (sanitize_phone_number(phone)) # Принтемо результат роботи *sanitize_phone_number(phone)

# ================================ Звдання 6 / Task 6 ======================================

# ================================  Ітератори/генератори (ключове слово yield) ============================== 

# Функції — це ізольовані набори інструкцій з однією точкою входу і однією точкою виходу. Іншими словами, коли ви викликаєте функцію, 
# то інтерпретатор виконає увесь її код від початку і до кінця при кожному виклику.

# Але, що якщо потрібно отримати такий ізольований набір інструкцій з декількома точками входу? Або, 
# що якщо ми хочемо продовжити виконання функції з якогось місця при наступному її виклику?

# Прикладом таких ситуацій може служити генератор випадкових чисел, який при кожному виклику видає нове "випадкове" число 
# і не повторює вже виданих. Або коли нам потрібна велика послідовність, 
# яку можна легко вичислити і було б невигідно зберігати в пам'яті цілком.

# Подібні завдання у Python вирішують ітератори і генератори. Один із способів створити ітератор або генератор у Python
# — це створити особливу функцію з декількома точками входу. Для цього використовується ключове слово yield.

# yield поводиться схожим чином з return, повертає управління потоком виконання програмою з тіла функції. 
# Але, на відміну від return, yield при наступному зверненні не розпочинає виконання функції з початку, а продовжує з місця зупинки.

# Звичайно така поведінка припускає, що десь в пам'яті повинна зберігатися інформація про те, 
# на чому виконання зупинилося і про стан локального простору імен.

# def interval_generator(x, y):
#     while x <= y:
#         yield x
#         x += 1


# five_to_ten_generator = interval_generator(5, 10)

# next(five_to_ten_generator) # 5
# next(five_to_ten_generator) # 6
# next(five_to_ten_generator) # 7
# next(five_to_ten_generator) # 8
# next(five_to_ten_generator) # 9
# next(five_to_ten_generator) # 10
# В даному прикладі ми створили генератор цілих чисел від x до y interval_generator. Щоб створити генератор чисел від 5 до 10, 
# ми викликали interval_generator, передавши в якості аргументів числа 5 та 10. Результат (сам генератор) 
# зберегли в five_to_ten_generator. Генератор — це не звичайна функція і, щоб отримати з нього значення, 
# можна скористатися вбудованою функцією next. Але це не найзручніший спосіб. 
# Найчастіше генератори використовуються безпосередньо в циклах for ...:

# def interval_generator(x, y):
#     while x <= y:
#         yield x
#         x += 1


# five_to_ten_generator = interval_generator(5, 10)
# for i in five_to_ten_generator:
#     print(i)
# Результат виконання цього коду буде абсолютно ідентичний. Ви вже стикалися з генераторами у Python, наприклад range — це генератор.

# Принципова відмінність генератора від ітератора в тому, що генератор обчислює наступне значення деякої послідовності у момент виклику,
# а ітератор перебирає збережену в пам'яті послідовність. З точки зору використання генератор і ітератор абсолютно ідентичні.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Нехай є рядок з числами (з метою спрощення числа лише цілі), що визначає якісь частини загального доходу. Наприклад,

# "The resulting profit was: from the southern possessions $ 100, from the northern colonies $500, and the king gave $1000."
# Необхідно реалізувати функцію generator_numbers, яка буде парсити рядок і знаходити всі цілі числа в ньому та працювати як генератор, 
# який буде віддавати зазначені числа при зверненні до нього у циклі.

# З парсингом рядків ми вже зіштовхувалися виконуючи завдання модуля 7, коли розбивали на лексеми арифметичний вираз

# Функція generator_numbers(string="") безпосередньо розпарсює рядок і за допомогою yield повертає поточне число.

# Функція sum_profit(string) підсумовує числа, отримані від generator_numbers, та повертає загальну суму прибутку з рядка.

# +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# Примітка : код написаний класично без замикань ітераторів і оператора yield . автоперевірка приняла без зауважен. 
#            Вся теорія вище нажаль невикористовувалсь. Можливо в наступних завданнх.

# LIST_NUMBERS = ['0', '1', '2', '3', '4','5', '6', '7','8', '9'] # Список константа , містить всі цифри записані в форматі *str

# def generator_numbers(string=""):
#     ''' Функція: Приймає один необовязковий аргумент *string="" , рядок з якого будемо шукати і повертати всі чила.
#                Повертає список який буде містити всі десяткові  числа з переданого значення *string '''
  
#     num = ''      # зміна в яку будемо формувати наші числа і добавляти їх до списку як тільки сформуємо , після кожного додавання в список будемо очищати.
#     list_num =[]  # Список в який будемо додавати наші числа і повертати з функції

#     for i in string :  # Цикл в якому будемо проходитись по кожному символу з переданого в функцію рядка *string, знаходити їх і добавляти 
#                         # в наш список *list_num
     
#         if i in LIST_NUMBERS :  # Перевірка чи поточний символ *i міститься в нашому списку *LIST_NUMBERS, якщо так значить це символ цифри.
#                                 #  методом конкатації(додовання) формуємо з нього число . Поки поточний символи знаходяться в *LIST_NUMBERS будемо його додавати в *num 
#                                 #  Ми допопереднього значення , додаєм наступне і так поки непопадеться не цифра . тоді *num сформується наше перше число
#                                 # і вийдемо з цієї умови .


#             num += i            # Додавання символа  в *num . Поки виконується умова  *if i in LIST_NUMBERS :
#                                 # ми посимвольно записуємо найдні цифри підряд.

#         else :  # Якщо умова не виконалась значить, поточний символ не цифра . Переходимо до подальшого аналізу
                               
#             if len(num) == 0:  # Перевіряємо довжину поточного *num. Якщо *num = 0 значить, поки числа не попадались.
           
#                 continue        # поки виконується умова if len(num)== 0  повертаємось на наступний крок циклу . за допомогою оператор *continue

#             else :  #  Якщо умова *if len(num)== 0: не виконалаcь, значить це символи числа. 
#                 num= int(num) # приводимо стрічку *num, яка містить символи числа (тип *str)< до чисельного типу *int.
#                               # В результаті стріча *"100" стане числом *100(перше знайдене число для нашого прикладу)
#                 list_num.append(num) # Додаємо наше число до списку ,

#                 num = '' # Переприсвоюємо *num пустий рядок . Щоб ,якщо в подальшому в стрічці ще зустрінуться числа, то записати нове число.

#     return list_num  # В кінці повертаємо список де елемантами будуть всі знайдені числа в рядку . 

# def sum_profit(string):  # 
#     ''' Основна функція, яка приймає один аргумент тип(*str) . За допомогою допоміжної функції *generator_numbers(string) аналізує його і 
#         повертає список всіх знайдених чисел із нього. За допомогою фінкції *sum(*list) - додаємо всі числа в спику і повертаємо їх суму '''

#     find_nums = generator_numbers(string)  # В *find_nums повертаємо список знайдених з *string чисел .

#     return sum(find_nums)  # За допомгою функції *sum(find_nums), знаходимо суму чисел  елементів списку і повертаємо її з функції.


    

# # # +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++ 

# string = "The resulting profit was: from the southern possessions $ 100, \
#     from the northern colonies $500, and the king gave $1000."  # Тестове значення .

# find_num = generator_numbers(string) # повертаємо результат роботи функції в *find_num, Поверне список чисел з рядка . Для контролю результату
# print (sum_profit(string)) # Принтимо результат повернутий з основної функції . Суму всіх чисел з рядка . В нашому випадку 1600 .


 
# ================================ Звдання 7 / Task 7 ======================================

# ================================ Функція lambda, map . ==============================



# Буває, що нам потрібна функція, суть якої можна викликати, передавши їй аргументи, але сама функція дуже проста 
# і її усю можна описати одним виразом. 
# У таких ситуаціях немає особливого сенсу створювати функцію, використовуючи стандартний синтаксис і захаращувати простір імен.

# Спеціально для таких випадків у Python є лямбда-функції або анонімні функції.

# sum_lambda = lambda x, y: x + y
# Синтаксис лямбда функцій:

# розпочинається з ключового слова lambda, після якого йде список позиційних аргументів функції через кому (аргументів може і не бути);
# потім йде двокрапка;
# далі йде тіло функції, суворо один вираз;
# результат виразу буде повернений як результат лямбди (return не потрібен).
# У прикладі вище ми створили лямбда-функцію sum_lambda, яка повертає суму двох чисел. 
# Насправді, це "поганий тон" зберігати лямбда-функції в змінних, вони повинні створюватися там же, 
# де і використовуватися і більше ніде у коді не залишають слідів.

# Один з прикладів використання лямбда-функцій — це генератор map.

# map приймає на вхід функцію і послідовність, повертає генератор, який застосовує до кожного елементу послідовності функцію.

# Давайте напишемо за допомогою map генератор, який возводить числа із списку numbers у квадрат:

# numbers = [1, 2, 3, 4, 5]

# for i in map(lambda x: x ** 2, numbers):
#     print(i)
# в результаті виконання цього коду ви побачите:

# 1
# 4
# 9
# 16
# 25
# В якості першого аргументу у map ми передали лямбда-функцію lambda x: x ** 2, яка повертає x у ступені 2.

# В результаті виконання виразу map(lambda x: x ** 2, numbers) ми отримаємо генератор, яким пройшлися в циклі for 
# та вивели значення на кожній ітерації функцією print.

# У map можна передавати будь-яку функцію, яка приймає один аргумент і будь-яку послідовність, 
# за якою можна ітеруватися (список, кортеж, словник, множини, другий генератор/ітератор).

# # ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Є список name з іменами користувачів, але всі починаються з малої літери.

# name = ["dan", "jane", "steve", "mike"]
# Розробіть функцію normal_name, яка приймає список імен та повертає теж список імен, але вже з правильними іменами з великої літери.

# ['Dan', 'Jane', 'Steve', 'Mike']
# Необхідно використовувати функцію map. Не забудьте, що необхідно виконати перетворення типів для map.

# # +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def normal_name(list_name):
#     '''Функція приймає один аргумент список , елементами якого є рядки, \
#         повертає той самий список тільки робить першу букву в рядку великою.'''
#     # Приклад: # Отримала  - ["dan", "jane", "steve", "mike"] 
#     #          # Повернула - ['Dan', 'Jane', 'Steve', 'Mike'] 

#     list_normal_names = [] # Пустий списко в який будемо додавати елементи з першою великою літерою

#     for name in map(lambda norm_name : norm_name.capitalize(), list_name) : # Цикл в якому будемо проходитись по обєктах типу *map і повертати їх в наш список *list_normal_names
#                             # Вбудований генератор *map - приймає на вхід функцію і послідовність, повертає генератор, який застосовує до кожного елементу послідовності функцію
#                             # Тобто для кожного елемента з *послідовності(другий аргумент) буде застосовано функцію і результат буде повернутий в обєкт типу *map вигляду: *<map object at 0x0000019C4B98A680> 
#                             # Доступ до обєктів типу *map можна отримати в циклі. При зверненні в циклі, повертає по елементно всі згенеровані обєкти, які знаходяться в генераторі,
#                             # того типу , якого їх повернула  функція ,яка є першим аргументом в генераторі *map . 
#                             # Для нашого прикладу .Функція *lambda norm_name : norm_name.capitalize() - повертає рядок(*str) ,який починається з великої літери.
                            
#         list_normal_names.append(name) # Добавляємо поточний елемент(повернутий рядок з генератора *map)  до нашого списку.
                                       

#     return list_normal_names # Повертаємо з функції сформований список . # *['Dan', 'Jane', 'Steve', 'Mike'] 

# # # # +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++

# list_name = ["dan", "jane", "steve", "mike"] # тестові значення .
# print(normal_name(list_name)) # Принтимо результати виконання функції .

# ================================ Звдання 8 / Task 8 ======================================

# ================================ Функція lambda, map . ==============================


# # ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++

# ==============================  ЗАВДАННЯ: ОТРИМАТИ EMAIL КОРИСТУВАЧІВ ==================

# Є список contacts, елементи якого - словники контактів наступного виду:

# {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача, його email, телефонний номер та властивість - обраний контакт чи ні.

# Розробіть функцію get_emails, яка отримує у параметрі список list_contacts та повертає список, 
# який містить електронні адреси всіх контактів зі списку list_contacts.
# Використовуйте функцію map.

# # +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def get_emails(list_contacts):
#     '''Функція приймає один аргумент список , елементами якого є словник(*dict), \
#         повертає список всіх емейлів  '''
#     # Приклад: # Отримала  - list_contacts = [
#             #     {"name": "Allen Raymond", "email": "nulla.ante@vestibul.co.uk", "phone": "(992) 914-3792", "favorite": False,},
#             #     {"name": "Den Mond", "email": "sara.ante@bul.ukr.uk", "phone": "(442) 714-4592", "favorite": True,},
#             #     {"name": "Reen Zhondar", "email": "daser@gmail.com", "phone": "(+382) 789-4558", "favorite": True,},
#             #     {"name": "Lenon Bonid", "email": "bonit.der.ase@com", "phone": "(142) 114-4596", "favorite": False,}
#             # ]
#     #          # Повернула - ['nulla.ante@vestibul.co.uk', 'sara.ante@bul.ukr.uk', 'daser@gmail.com', 'bonit.der.ase@com']

#     list_email = [] # Пустий список в який будемо додавати витягнутий з кожного словника email.

#     for dict_contact in map(lambda current_dict : current_dict, list_contacts ) : # Цикл в якому будемо проходитись по обєктах типу *map і повертати їх в наш список *list_email
#                             # Вбудований генератор *map - приймає на вхід функцію і послідовність, повертає генератор, який застосовує до кожного елементу послідовності функцію
#                             # Тобто для кожного елемента з *послідовності(другий аргумент) буде застосовано функцію і результат буде повернутий в обєкт типу *map вигляду: *<map object at 0x0000019C4B98A680> 
#                             # Доступ до обєктів типу *map можна отримати в циклі. При зверненні в циклі, повертає по елементно всі згенеровані обєкти, які знаходяться в генераторі,
#                             # того типу , якого їх повернула  функція ,яка є першим аргументом в генераторі *map . 
#                             # Для нашого прикладу .Функція *lambda current_dict : current_dict, - повертає елемент списку - словник(*dict) , 
#                             # Тобто при проходжені в циклі по генератору *map , на кожній ітерації циклу, буде повертатись поточний елемент списку *list_contacts який є словником.
#                             # Приклад : # на першій ітерації, поточний елемент *dict_contact = {"name": "Allen Raymond", "email": "nulla.ante@vestibul.co.uk", "phone": "(992) 914-3792", "favorite": False,}
#                                         # на наступній ітерації , поточний елемент *dict_contact = {"name": "Den Mond", "email": "sara.ante@bul.ukr.uk", "phone": "(442) 714-4592", "favorite": True,}
#                                         # і так поки незакінчаться елементи списку *list_contacts 
                            
#         list_email.append(dict_contact["email"]) # Добавляємо поточний елемент, отримане відповідне значення ключа "email" з поточного словника *dict_contact, до нашого списку.
                                       

#     return list_email # Повертаємо з функції сформований список . # *['nulla.ante@vestibul.co.uk', 'sara.ante@bul.ukr.uk', 'daser@gmail.com', 'bonit.der.ase@com']
   



#  # # # +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++

# list_contacts = [
#                 {"name": "Allen Raymond", "email": "nulla.ante@vestibul.co.uk", "phone": "(992) 914-3792", "favorite": False,},
#                 {"name": "Den Mond", "email": "sara.ante@bul.ukr.uk", "phone": "(442) 714-4592", "favorite": True,},
#                 {"name": "Reen Zhondar", "email": "daser@gmail.com", "phone": "(+382) 789-4558", "favorite": True,},
#                 {"name": "Lenon Bonid", "email": "bonit.der.ase@com", "phone": "(142) 114-4596", "favorite": False,}
#             ]  # Тестове значення .

# print (get_emails(list_contacts)) # Принтимо результат роботи функції.


# ================================ Звдання 9 / Task 9 ======================================

# ================================ Функція lambda, filter. ==============================

# Аналогічний map синтаксис у filter. filter теж приймає на вхід функцію та послідовність і повертає генератор. 
# Головна відмінність у тому, що filter застосовує функцію до кожного елемента послідовності та повертає тільки елементи, 
# які дають "truthy" результати.

# Нагадаємо, що у Python можна будь-який тип привести до boolean. 
# До False наводяться 0, None та порожні контейнери,рядки, списки, словники, множини, кортежі, 
# всі інші випадки наводяться до True (вони ще називаються "truthy").

# Наприклад виведемо список чисел, які діляться на 2 із залишком в інтервалі від 1 до 10:

# for i in filter(lambda x: x % 2, range(1, 10 + 1)):
#     print(i)
# У цьому прикладі ми передали в filter лямбда функцію lambda x: x % 2, яка повертає залишок від ділення.
# Для кожного елемента послідовності з генератора range(1, 10+1) filter виконав перевірку лямбда-функцією та, 
# якщо вона (лямбда) повернула "truthy" результат, то цей результат потрапляв у відфільтровану послідовність на виході.

# Інший приклад, давайте відфільтруємо з рядка літери верхнього регістру, щоб залишилися лише літери нижнього:

# some_str = 'aaAbbB C F DDd EEe'
# for i in filter(lambda x: x.islower(), some_str):
#     print(i)


# # ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++

# На початку четвертого модуля ми вирішували завдання виплат за комунальними платежами. 
# Вони являли собою список payment з додатними та від'ємними значеннями. 
# Створіть функцію positive_values та за допомогою функції filter відфільтруйте список payment за додатними значеннями, 
# та поверніть його з функції.

# payment = [100, -3, 400, 35, -100]

# # +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def positive_values(list_payment):
#     '''Функція - Отримує один аргумент - список з числами
#                - Повертає - список тільк тих які додатні (результат отриманий за допомогою генератора *filter) '''
#     # Приклад : # Приймає   - [100, -3, 400, 35, -100]
#                 # Повертає  - [100, 400, 35]

#     list_positive_balans = [] # Пустий список в який будемо додобаляти тільки додатні числа з отриманого в функцію списку .

#     for payment in filter(lambda current_payment : current_payment > 0, list_payment ) :# Цикл в якому будемо проходитись по обєктах типу *filter і повертати їх в наш список *list_positive_balans
# #                             # Вбудований генератор *filter - працює так сомо як і *map.
#                               # Головна відмінність у тому, що filter застосовує функцію до кожного елемента послідовності та повертає тільки елементи,
#                               # які дають "truthy" результати.("truthy" - це ті які відповідають *True)
# #                             # Тобто для кожного елемента з *послідовності(другий аргумент) , буде застосовано функцію, і тільки ті результати, які будуть задовільнати умову (тобто *True) ,
#                               # будуть повернуті в обєкт типу *filter вигляду: *<filter object at 0x0000019C4B98A680> 
#                               # Доступ до обєктів типу *filter можна отримати в циклі. При зверненні в циклі, повертає по елементно всі згенеровані обєкти, які знаходяться в генераторі,
# #                             # того типу , якого їх повернула  функція ,яка є першим аргументом в генераторі *filter . 
# #                             # Для нашого прикладу .Функція *lambda current_payment : current_payment > 0, - повертає елемент списку - числа , які більші 0 , тобто додаті. 
# #                             # Тобто при проходжені в циклі по генератору *filter  , на кожній ітерації циклу, буде повертатись поточний елемент списку *list_payment, який є числом і більший нуля.
# #                             # Приклад : # на першій ітерації, поточний елемент *payment = 100
# #                                         # на наступній ітерації , поточний елемент *payment = 400 
# #                                         # і так поки незакінчаться елементи списку *list_payment 
#                               # Примітка : # Хоча наступний елемент списку *list_payment , після 100 йде -3. він не попаде в обєкти *filter , бо не пройде умову -3 > 0 , 
#                                            # Тому всі відємні числа, для такої умови, будуть *False , а генератор *filter зберегає тільки *True обєкти(*"truthy")
                                           

#         list_positive_balans.append(payment) # Добавляємо поточний елемент(повернуте додатнє число  з генератора *filter)  до нашого списку
    
#     return list_positive_balans  # Повернення з функції результату # [100, 400, 35]


# #  # # # +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++

# list_payment = [100, -3, 400, 35, -100] # тестове значення 

# print(positive_values(list_payment)) # Принтимо результат для тестовго значення. # [100, 400, 35]


# ================================ Звдання 10 / Task 10 ======================================

# ================================ Функція lambda, filter. ==============================

# ============================  ЗАВДАННЯ: ВІДФІЛЬТРУВАТИ КОРИСТУВАЧІВ  ==================

# # ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++

# Є список contacts, елементи якого - словники контактів наступного виду:

#     {
#     "name": "Allen Raymond",
#     "email": "nulla.ante@vestibul.co.uk",
#     "phone": "(992) 914-3792",
#     "favorite": False,
# }
# Словник містить ім'я користувача, його email, телефонний номер та властивість - обраний контакт чи ні.

# Створіть функцію get_favorites(contacts), яка повертатиме список, який містить лише обрані контакти. 
# Використовуйте при цьому функцію filter, щоб відфільтрувати по полю favorite лише обрані контакти.

# # +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def get_favorites(contacts):
#     '''Функція приймає один аргумент список , елементами якого є словник(*dict), \
#         повертає список тих словників  які в ключі "favorite": True '''
#     # Приклад: # Отримала  - contacts = [
#             #     {"name": "Allen Raymond", "email": "nulla.ante@vestibul.co.uk", "phone": "(992) 914-3792", "favorite": False,},
#             #     {"name": "Den Mond", "email": "sara.ante@bul.ukr.uk", "phone": "(442) 714-4592", "favorite": True,},
#             #     {"name": "Reen Zhondar", "email": "daser@gmail.com", "phone": "(+382) 789-4558", "favorite": True,},
#             #     {"name": "Lenon Bonid", "email": "bonit.der.ase@com", "phone": "(142) 114-4596", "favorite": False,}
#             # ]
#     #          # Повернула - contacts = [
#             #     {"name": "Den Mond", "email": "sara.ante@bul.ukr.uk", "phone": "(442) 714-4592", "favorite": True,},
#             #     {"name": "Reen Zhondar", "email": "daser@gmail.com", "phone": "(+382) 789-4558", "favorite": True,}
#     #         ]

#     list_dicts_true = [] # Пустий список в який будемо додавати словники які в ключі "favorite": True .    

#     for dict_contact in filter(lambda current_dict : current_dict, contacts ) :# Цикл в якому будемо проходитись по обєктах типу *filter і повертати тільки ті з них, які в за ключем *"favorite" мають значення *True, в наш список *list_dicts_true
# # #                             # Вбудований генератор *filter - працює так сомо як і *map.
# #                               # Головна відмінність у тому, що filter застосовує функцію до кожного елемента послідовності та повертає тільки елементи,
# #                               # які дають "truthy" результати.("truthy" - це ті які відповідають *True)
# # #                             # Тобто для кожного елемента з *послідовності(другий аргумент) , буде застосовано функцію, і тільки ті результати, які будуть задовільнати умову (тобто *True) ,
# #                               # будуть повернуті в обєкт типу *filter вигляду: *<filter object at 0x0000019C4B98A680> 
# #                               # Доступ до обєктів типу *filter можна отримати в циклі. При зверненні в циклі, повертає по елементно всі згенеровані обєкти, які знаходяться в генераторі,
# # #                             # того типу , якого їх повернула  функція ,яка є першим аргументом в генераторі *filter . 
# # #                             # Для нашого прикладу .Функція *lambda current_dict : current_dict, contacts, - поверне всі елементи списку ,тобто всі словники. Ми не вказували якоїсь умови, тому всі елементи списку будуть *True. 
# # #                             # Тобто при проходжені в циклі по генератору *filter  , на кожній ітерації циклу, буде повертатись поточний елемент списку *contacts, який є словником.
# # #                             # Приклад : # на першій ітерації, поточний елемент     *current_dict = {"name": "Allen Raymond", "email": "nulla.ante@vestibul.co.uk", "phone": "(992) 914-3792", "favorite": False,}
# # #                                         # на наступній ітерації , поточний елемент *current_dict = {"name": "Den Mond", "email": "sara.ante@bul.ukr.uk", "phone": "(442) 714-4592", "favorite": True,}
# # #                                         # і так поки незакінчаться елементи списку *contacts 
# #                               # Примітка : # Хоча ми застосовуємо генератор  *filter(без додаткової умови) , то в його обєкти попадуть всі елементи списку, оскільки будь який *dict - це існуючий тип даних, тобто *True
         
#          if dict_contact["favorite"] : # Умова де перевіряємо значення ключа *"favorite" з поточого словника *dict_contact .
#                                        # Оскільки занчення за ключем *"favorite" є (*True або *False) то умова *if False ніколи не виконається. (Пояснення шукай в інтрнеті.)-  
#               list_dicts_true.append(dict_contact) # Добавляємо поточний елемент, *dict_contact, до нашого списку.
   


#     return list_dicts_true # Повертаємо з функції сформований список . # [{'name': 'Den Mond', 'email': 'sara.ante@bul.ukr.uk', 'phone': '(442) 714-4592', 'favorite': True}, {'name': 'Reen Zhondar', 'email': 'daser@gmail.com', 'phone': '(+382) 789-4558', 'favorite': True}]
   


# #  +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++

# contacts = [
#                 {"name": "Allen Raymond", "email": "nulla.ante@vestibul.co.uk", "phone": "(992) 914-3792", "favorite": False,},
#                 {"name": "Den Mond", "email": "sara.ante@bul.ukr.uk", "phone": "(442) 714-4592", "favorite": True,},
#                 {"name": "Reen Zhondar", "email": "daser@gmail.com", "phone": "(+382) 789-4558", "favorite": True,},
#                 {"name": "Lenon Bonid", "email": "bonit.der.ase@com", "phone": "(142) 114-4596", "favorite": False,}
#             ]  # Тестове значення .

# print (get_favorites(contacts)) # Принтимо результат роботи функції.

# ================================ Звдання 11 / Task 11 ======================================

# ================================ Ітератори . Функція Reduce Бібліотека functools  ==============================

# Reduce знаходиться в модулі functools у Python 3.0. Це складніша функція у порівнянні з map або filter. 
# Вона приймає ітератор для обробки, але сама не є ітератором і повертає єдиний результат.

# Функція reduce застосовує функцію з двома параметрами кумулятивно до елементів, що підлягають ітерації,
# необов'язково починаючи з початкового аргументу. Має наступний синтаксис:

# reduce(func, iterable[, initial])
# де: func — це функція, до якої кумулятивно застосовується кожен елемент iterable, 
# а initial — необов'язкове значення, яке поміщається перед елементами обчислення, що ітерується,
# і служить значенням за замовчуванням, коли об'єкт, що ітерується, порожній.

# Найкраще, щоб зрозуміти принцип роботи reduce, це розглянути приклад.

# from functools import reduce

# result = reduce((lambda x, y: x * y), [1, 2, 3, 4])

# print(result)  # 24
# Яким чином змінна result набула значення 24? Розглянемо покроково:

# крок №1
# x = 1, y = 2 — значення першого та другого елемента списку iterable. Результат лямбда функції — 2.

# крок №2
# x = 2 — це результат попереднього обчислення лямбда функції y = 3 - значення третього елемента списку iterable. 
# Результат лямбда функції – 6.

# крок №3
# x = 6 — це результат попереднього обчислення лямбда функції y = 4 - значення четвертого елемента списку iterable.
# Результат лямбда функції – 24. Виконання reduce закінчилося.

# Якщо використовувати необов'язкове початкове значення:

# from functools import reduce

# result = reduce((lambda x, y: x * y), [1, 2, 3, 4], 3)

# print(result)  # 72
# крок №1
# x = 3, y = 1 — в x необов'язкове значення 3, y - перший елемент списку iterable. Результат лямбда функції - 3.

# крок №2
# x = 3 — це результат попереднього обчислення лямбда функції y = 2 - значення другого елемента списку iterable. 
# Результат лямбда функції - 6.

# крок №3
# x = 6 — це результат попереднього обчислення лямбда функції y = 3 - значення третього елемента списку iterable. 
# Результат лямбда функції - 18.

# крок №4
# x = 18 — це результат попереднього обчислення лямбда функції y = 4 - значення четвертого елемента списку iterable. 
# Результат лямбда функції - 72. Виконання reduce закінчилося.

# Підведемо підсумок. Як бачимо, reduce() приймає функцію func і послідовність iterable та повертає одне значення, 
# яке розраховується так:

# Спочатку функція func викликається з першими двома елементами із послідовності iterable, та повертає результат.
# Потім функція func викликається знову з результатом, отриманим на кроці 1, та наступним значенням у послідовності iterable.
# Цей процес повторюється до того часу, поки в послідовності iterable не закінчаться елементи.

# # ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++

# Для списку numbers підрахувати суму елементів за допомогою функції reduce.

# numbers = [3, 4, 6, 9, 34, 12]
# Створіть функцію sum_numbers(numbers), результатом виконання якої буде сума чисел всіх елементів списку numbers.

# # +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from functools import reduce


# def sum_numbers(numbers):
#     '''Функція приймає один аргумент список , елементами якого є числа(*int), \
#         повертає суму всіх чисел з списку.(використання функці reduce(func, iterable[, initial]) з бібліотеки functools ) '''
#     # Приклад: # Отримала  - *numbers = [3, 4, 6, 9, 34, 12]
#     #          # Повернула - 68 
   
#     return reduce((lambda x, y: x + y), numbers) # Оскільки *reduce - завжди повертає результат того що внього в аргументах, то відразу його повертаємо з функції.
#                                                  # Примітка .Як працює функція  *reduce - читай в теорії до цього завдання, там все ок описано на прикладах.


# # #  +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++

# numbers = [3, 4, 6, 9, 34, 12] # # Тестове значення .

# print(sum_numbers(numbers)) # Принтимо результат роботи функції.

# ================================ Звдання 12 / Task 12 ======================================

# ================================ Ітератори . Функція Reduce Бібліотека functools  ==============================

# # ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++

# Повернемося до нашого першого завдання з четвертого модуля і перепишемо його за допомогою функції reduce.

# payment = [1, -3, 4]


# def amount_payment(payment):
#     sum = 0
#     for value in payment:
#         if value > 0:
#             sum = sum + value
#     return sum
# Нагадаємо умову. У нас є список показань заборгованостей з комунальних послуг наприкінці місяця. 
# Заборгованості можуть бути від'ємними — у нас переплата, чи додатними, якщо необхідно сплатити за рахунками.
# За допомогою reduce підсумуйте додатні значення та поверніть з функції amount_payment суму платежу в кінці місяця.

# # +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# from functools import reduce


# def amount_payment(payment):
# #   ''Функція приймає один аргумент список , елементами якого є числа(*int), \
# #         повертає суму всіх додатніх чисел з списку.(використання функці reduce(func, iterable[, initial]) з бібліотеки functools ) '''
# #     # Приклад: # Отримала  - *payment = [1, -3, 4, 3, -4, 6, 9, -34, 12]
# #     #          # Повернула - 35 

#     list_positiv_balans = [] # Пустий список в який будемо додобаляти тільки додатні числа з отриманого в функцію списку .


#     for elm in filter(lambda x: x > 0 , payment): # В циклі проходимось по елементах обєкту *filter і добавляємо їх в список *list_positiv_balans.
#                                                   # генератор *filter буде містити всі елементи вхідного списку *payment які відповідають умові x > 0,де х поточний елемент списку *payment.
#                                                   # для нашого прикладу всі додатні числа з списку *payment
#         list_positiv_balans.append(elm) # добавляємо поточний елемент в наш список.
    
#     return reduce((lambda x, y: x + y), list_positiv_balans) # Повертаємо відразу значення отримане з функції *reduce - це й буде сума всіх додатніх чисел з списку *payment
#                                                              # де *list_positiv_balans це попердньо сформований список в циклі за допомогою генератора *filter
#                                                              # Примітка : детальнішй опис як працює генератор *filter - дивись завдання 9 - теорія і в коді.
#                                                                                         # як працює функція  * reduce - дивись завдання 11 - теорія 


# # # #  +++++++++++++++++++++++++++++++ Тестові значення і виклик функції в основному тілі коду  +++++++++++++++++++


# payment = [1, -3, 4, 3, -4, 6, 9, -34, 12] # Тестові значення

# print(amount_payment(payment)) # принтимо результат роботи функції для наших тестових значень. # 35


                






