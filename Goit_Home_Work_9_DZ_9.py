# ===================  Home work 9 ========================

# =================    Функції (декоратори, замикання)  =================

    # 1. Функція як об'єкт першого класу
    # 2. Області видимості (LEGB)
    # 3. ЗАМИКАННЯ
    # 4.  КАРРУВАННЯ
    # 5. Декоратори
    # 6. Ітератори/генератори (ключове слово yield)
    # 7. Лямбда-функції (анонімні функції)
    # 8. MAP
    # 9. Filter

# ================================================================


# ================================ Звдання 1 / Task 1 ======================================

# ================================ Функція як обєкт першого класу . Виклик функції з іншої функції. =================================

# Wikipedia

# У програмуванні функція, яка приймає як аргументи інші функції або повертає іншу функцію в якості результату.
# Основна ідея у тому, що функції мають той самий статус, як і інші об'єкти даних.

# Оскільки у Python функції – це об'єкти першого класу, то вони є HOF (High Order Functions), 
# ця властивість активно використовується для розробки програмного забезпечення.

# На практиці це означає, що ми можемо працювати з функціями у Python точно так, як з будь-якими іншими типами даних:

# можемо створювати змінні і записувати в них функції;

#   def func(x, y):
#       return x + y

#   func_alias = func
#   result = func_alias(2, 3)
#   print(result)  # 5
# можемо передавати функцію як аргументи для інших функцій;

#   def sum_func(x, y):
#       return x + y

#   def subtraction_func(x, y):
#       return x - y

#   def tricky_func(x, y, func):
#       return func(x, y)

#   sum_result = tricky_func(2, 3, sum_func)
#   min_result = tricky_func(2, 3, subtraction_func)

#   print(sum_result)  # 5
#   print(min_result)  # -1
# можемо повертати з функції інші функції.

#   def sum_func(x, y):
#       return x + y

#   def subtraction_func(x, y):
#       return x - y

#   def get_operator(operator):
#       if operator == '+':
#           return sum_func
#       elif operator == '-':
#           return subtraction_func
#       else:
#           print('Unknown operator')

#   sum_action_function = get_operator("+")
#   print(sum_action_function(2, 3))    # 5

#   sub_action_function = get_operator("-")
#   print(sub_action_function(2, 3))    # -1
# Таким чином з функціями у Python можна працювати так само, як і з будь-якими іншими об'єктами.


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Повернемося до завдання про систему оцінок в університеті, які мають такий вигляд:

# Оцінка	Бали	Оцінка ECTS	    Пояснення

# 1	    0-34	    F	       Unsatisfactorily
# 2	    35-59	    FX	       Unsatisfactorily
# 3	    60-66	    E	       Enough
# 3	    67-74	    D	       Satisfactorily
# 4	    75-89	    C	       Good
# 5	    90-95	    В	       Very good
# 5	    96-100	    A	       Perfectly

# Минулого разу ми реалізували дві функції. Перша - get_grade, 
# приймає ключ в оцінці ECTS і повертає відповідну п'ятибальну оцінку (перший стовпчик таблиці).
# Друга - get_description, теж приймає ключ у оцінки ECTS, але повертає пояснення оцінки у текстовому форматі (останній стовпчик таблиці).
# На неіснуючий ключ функції повинні повертати значення None.

# Реалізуйте функцію вищого порядку get_student_grade, яка приймає параметр option. Якщо він дорівнює значенням "grade", 
# то функція повертає функцію get_grade, а якщо його значення дорівнює "description", то повертає функцію get_description. 
# Якщо параметр за значенням не співпав із заданими, то функція get_student_grade повинна повертати значення None.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def get_grade(key):
#     ''' Функція за ключем *key , повертає значення з словника *grade.\
#         якщо вказати невіриний ключ поверне заначення *None.'''
# 
#     grade = {"A": 5, "B": 5, "C": 4, "D": 3, "E": 3, "FX": 2, "F": 1}
#     return grade.get(key, None)


# def get_description(key):
#     ''' Функція за ключем *key , повертає значення з словника *description.\
#         якщо вказати невіриний ключ поверне заначення *None.'''
# 
#     description = {
#         "A": "Perfectly",
#         "B": "Very good",
#         "C": "Good",
#         "D": "Satisfactorily",
#         "E": "Enough",
#         "FX": "Unsatisfactorily",
#         "F": "Unsatisfactorily",
#     }
#     return description.get(key, None)

# def get_student_grade(option):
#     '''Функція приймає один аргумент *option, і якщо він містить змінні *get_description або *get_grade, \
#     то повертає відповідні функції за іменем оголошених функції після  оператора def *імя_функції(*аргументи_або_без_аргументів).\
#         Якщо аргументи, в оголошених функціях, відсутні в тілі коду обо повертати з основної функції тільки імя додаькової функції,\
#               то повертає клас *<function *імя_функції at *область_памяті_OS> на який вказує *optionю \
#                 Якщо аргумент оголошений в коді, і, в основновній функції повертає фінкцію, а не тільки їмя, то поверне результат отриманий з додаткової функції '''
 
#     if option == get_description: # Перевірка чи *option = get_description
#         return get_description    # якщо виконалась умова *if option == get_description - поверне *<function get_description at 0x000001B3B7327F60>
    
#     elif option == get_grade:     # Перевірка чи *option = get_grade
#         return get_grade          # якщо виконалась умова *elif option == get_grade - поверне *<function get_grade at 0x000001CB0CBF8A40>
#     else:
#        return None                # Поверне *None якщо жодна з попередніх умов невиконається .

# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# # key = "A" # Тестове значення.    
# # option = get_description # Тестове значення  # *<function get_description at 0x000001B3B7327F60>
# # option = get_grade  # Тестове значення  #  *<function get_grade at 0x000001CB0CBF8A40>
# # option = "asd"  # Тестове значення # *None

# # print(get_student_grade(option)) 

# +++++++++++++++++++++++ Для автоперевіки Код буде наступний +++++++++++++++++

# def get_student_grade(option):
    
#    if option == "description":
       
#        return get_description
   
#    elif option == "grade": 
#        return get_grade
#    else:
#        return None
   
# ================================ Звдання 2 / Task 2 ======================================

# ================================  Область видимості . Global Scope , Local Scope  =================================

# Область видимості — це область у програмі (коді), в межах якої ви можете звернутися по імені до вмісту змінної 
# (або як ми вже з'ясували функції). У Python можна виділити дві великі області видимості:

# глобальну (Global Scope). Все, що оголошено в цій області, буде доступне в будь-якій частині вашого додатку;
# локальну (Local Scope). Все, що оголошено в локальній області видимості, буде доступно тільки всередині неї.
# Глобальна область видимості лише одна і в ній міститься все, що ви оголосили на рівні модулю (змінні, функції, інші модулі і т.п).

# Локальна область видимості створюється, коли інтерпретатор потрапляє усередину функції.

# SOME_VAR = 3


# def func(x):
#     SOME_VAR = x
#     print(SOME_VAR)


# def procedure()
#     print(SOME_VAR)


# procedure()  # 3
# func(5)  # 5
# print(SOME_VAR)  # 3
# Давайте розберемо на цьому прикладі, як працюють області видимості. Змінна SOME_VAR оголошена на рівні модулю у глобальній області видимості 
# (так само, як і функції func та procedure).

# Коли ми викликаємо procedure усередині неї створюється локальна зона видимості. 
# У локальній для procedure області видимості немає SOME_VAR, і коли ми виконуємо вираз print(SOME_VAR), 
# Python спочатку шукає SOME_VAR у локальній області видимості, не знаходить і йде шукати у глобальній, де і знаходить SOME_VAR рівне 3.

# Коли ми викликаємо func, усередині неї створюється локальна зона видимості.
# В цій локальній області ми створюємо змінну SOME_VAR і привласнюємо їй значення 5.
# У цей момент глобальна зона видимості ніяк не змінюється, нова SOME_VAR існує тільки всередині func. 
# На підтвердження цього ми виконуємо print(SOME_VAR) на рівні модуля і отримуємо 3, що каже про те, 
# що всередині func існувала своя окрема змінна з ім'ям SOME_VAR.

# Щоб краще розуміти, що таке зона видимості, слід зрозуміти як працює їх механіка.

# У Python області видимості реалізовані як словники, в яких ім'я змінної або функції (рядок) — це ключ, 
# а сам об'єкт — це значення в цьому словнику.

# Таким чином, коли ви у коді виконали x = 2, в словнику простору імен (той же, що і область видимості) додалася пара: 'x': 2. 
# І коли десь далі вам потрібно отримати значення x із цього словника, буде взято значення 2, знайдене по ключу 'x'.

# Коли створюється нова зона видимості (простір імен), то насправді створюється новий подібний словник 
# (старий нікуди не дівається звичайно ж).

# Тут можна зробити важливий висновок, у вас в коді може одночасно існувати декілька просторів імен, які не взаємодіють один з одним. 
# Це у свою чергу означає, що пошук об'єктів по імені повинен відбуватися за якимсь правилом.

# У Python правила пошуку імен дуже прості:

# спочатку пошук йде в локальному просторі імен (LOCAL);
# якщо не знайдено в локальному, то в локальному на наступному рівні (ENCLOSED) і так далі, поки локальні не закінчаться;
# далі буде перевірено глобальний (GLOBAL) простір імен (рівень модуля);
# і в останню чергу простір вбудованих імен (BUILT INS) — це ключові слова і функції, що є частиною мови Python.
# Якщо ніде не знайдено сутності з таким ім'ям, то отримаємо виключення.

# Це правило можна запам'ятати по його акроніму: (LOCAL, ENCLOSED, GLOBAL, BUILT INS).

# У цьому правилі ми не розглянули, що таке ENCLOSED.

# GLOBAL_SCOPE_VAR = 1

# def func():
#     enclosed_scope_var = 2

#     def inner():
#         inner_var = 3
# В цьому коді всередині функції func оголошена функція inner. 
# Для функції func enclosed_scope_var та inner — знаходиться в LOCAL області видимості. 
# Для функції inner змінна inner_var буде в її локальній області видимості, 
# а вже enclosed_scope_var буде в ENCLOSED, в локальному просторі, але на рівень вище.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++


# Реалізуйте функцію get_discount_price_customer для розрахунку ціни на товар інтернет-магазину з урахуванням знижки клієнта.

# Функція приймає два параметри:

# price — ціна продукту
# customer — словник з даними клієнта такого виду: {"name": "Dima"} або {"name": "Boris", "discount": 0.15}
# Ви маєте глобальну змінну DEFAULT_DISCOUNT, яка визначає знижку для клієнта, якщо у нього немає поля discount.

# Функція get_discount_price_customer має повертати нову ціну товару для клієнта.

# Нагадаємо, що дисконт discount - це дробове число від 0 до 1. І ми під знижкою розуміємо коефіцієнт, який визначає величину ціни. 
# І на цю величину ми знижуємо підсумкову ціну товару: price = price * (1 - discount).

# +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# DEFAULT_DISCOUNT = 0.05 # Глобальна константа( зміна )


# def get_discount_price_customer(price, customer):
#     '''Функція яка приймає два аргумента, 
#      *price(тип *int) і *customer(тип *dict).
#      Повертає *product_price(тип *float) - вартість товару з врахуванням знижки'''
    
#     disc = customer.get("discount")  # *customer.get("discount") - повертаємо в *disc, значення з *customer, за ключем *"discount" методом -*.get(*key)
#                                      # Метод *імя_словника.get("*ключ") - за вказаним ключем повертає з словника відповідне значення. 
#                                      # Якщо вказаного ключа не має в словнику то повертає *None 
    
#     if disc != None:                        # Умова для перевірки за значеням  *disc .Якщо значення не *None, значить в поточному словнику є ключ *"discount" 
#                                             # Тобто в даного користувача є персональна знижка . Варість розраховуємо з врахуванням пересональної знижки. 
#         product_price = price * (1-disc)    # Формула розрахунку вартості товару з урахуванням персональної знижки. *product_price = 100*(1-0.15)
#         return product_price                # Тестове повернення: *product_price = 85
    
#     else:                                   # Якщо умова не виконалась, тобто в *customer не має ключа *"discount". Розраховуємо вартсть товару з врахуванням загальної знижки *DEFAULT_DISCOUNT
#         product_price = price * (1-DEFAULT_DISCOUNT) # Формула розрахунку вартості товару з урахуванням загальної знижки. *product_price = 100*(1-0.05)
#         return product_price                # # Тестове повернення: *product_price = 95
    
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# price = 100  # Тестове значення

# customer = {"name": "Dima"}  # Тестове занчення що немістить ключа *"discount"

# customer = {"name": "Boris", "discount": 0.15} # # Тестове занчення що містить ключ *"discount"

# print(get_discount_price_customer(price, customer)) # Принтимо значення яке поверне функція *get_discount_price_customer(price, customer)


# ================================ Звдання 3 / Task 3 ======================================

# ================================  Концепція замикання . ============================== 
#===========   функцію caching_fibonacci(), яка матиме кеш із попередньо обчисленими значеннями чисел Фібоначі =================================

# Особливість існування вкладених локальних просторів імен і той факт, що вони створюються динамічно,
# дає можливість використати механізм замикань у Python.

# Найпростіше це пояснити на прикладі:

# def adder(val):
#     def inner(x):
#         return x + val
#     return inner


# two_adder = adder(2)
# print(two_adder(3)) # 5
# print(two_adder(5)) # 7

# three_adder = adder(3)
# print(three_adder(5))   # 8
# print(three_adder(-3))  # 0

# id(two_adder) == id(three_adder)    # False
# В даному прикладі ми створили функцію adder, яка повертає внутрішню функцію inner. 
# Коли інтерпретатор заходить в adder (наприклад у виразі two_adder = adder(2)) створюється новий локальний простір імен в adder, 
# де створюється функція inner, яка і повертається з функції. Що не очевидно, так це те, що новостворена inner, коли її викликають,
# буде використовувати те значення val, яке було в adder на момент її створення.

# Коли ми виконали two_adder = adder(2), в two_adder записали функцію inner, яка буде додавати 2 до x. 
# А коли виконали three_adder = adder(3), то в three_adder записали inner, яка буде завжди додавати 3 до x.

# two_adder та three_adder — це дві різні функції, про що каже результат перевірки їх ідентифікаторів 
# (вираз id(two_adder) == id(three_adder)).
  
# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Концепцію замикання може добре пояснити приклад кешування значень функції.

# Підсумкове завдання модуля 3 було — рекурсивне обчислення чисел Фібоначчі.

# Ряд Фібоначчі - це послідовність чисел виду: 0, 1, 1, 2, 3, 5, 8, ..., 
# де кожне наступне число послідовності виходить додаванням двох попередніх членів ряду.

# У загальному вигляді для обчислення n-го члена ряду Фібоначчі потрібно вирахувати вираз: Fn = Fn-1 + Fn-2.

# Це завдання можна вирішити рекурсивно, викликаючи функцію, що обчислює числа послідовності доти, 
# доки виклик не сягне членів ряду менше n = 1, де послідовність задана.

# Створіть функцію caching_fibonacci(), яка матиме кеш із попередньо обчисленими значеннями чисел Фібоначі.
# Усередині вона містить функцію fibonacci(n), яка безпосередньо і обчислюватиме саме число Фібоначчі. 
# Функція caching_fibonacci() повертає функцію fibonacci

# Якщо число Фібоначчі зберігається у словнику cache, то функція fibonacci повертає число з кеша. 
# Якщо його немає у кеші, то ми обчислюємо число і поміщаємо його в кеш, і повертаємо з функції fibonacci.

# +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

def caching_fibonacci():
    '''Функція (без аргументів), яка викликає і повертає вбудовану функцію *fibonacci(n,cache = {}), за її іменем *fibonacci \
         Виклик ,вбудованої функції за іменем, дозволяє присвоювати її будь якій змінній в тілі програми в Глобальному просторі коду,\
         з довільним іменем зміної аргументу. Тобто значення зміної *n ,в вбудованій функції *fibonacci(n,cache = {}),\
         *НАПЕРЕД НЕ ВИЗНАЧЕНЕ* в локльному просторі і може бути довільним. \
           в описі вбудованої функції *def fibonacci(n,cache = {}) - міститься код, який описує, що треба буде зробити з *n, якщо його значення буде передано в функцію з Глобального простору.\
         Тобто передача значення аргумента *n в *fibonacci(n,cache = {}) з глобального простору , відбувається за наступною схемою:
         *імя_зміної = *функція_що_повертає_вбудовану_функцію_за_її_іменем. 
         *імя_зміної(*імя_аргумету_що_передається_в_вбудовану_функію_як_аргумент_n)
         
         *Приклад для нашого коду:  *call_local_func_fibonacci = caching_fibonacci() # Присвоюємо *call_local_func_fibonacci локальний простір з *сaching_fibonacci(), # *call_local_func_fibonacci = <function caching_fibonacci.<locals>.fibonacci at 0x000001983E2C7F60>
                                                                                    #  що містить повернутий локальний простір з функції *fibonacci .                  # *fibonacci = <function caching_fibonacci.<locals>.fibonacci at 0x000002A455227F60>
                                                                                    #  
                                    *call_local_func_fibonacci(num_fibon) # Де *call_local_func_fibonacci- виклик функції *caching_fibonacci(),
                                                                          # а *num_fibon - конкертне значення, з Глобального простору, яке передається локальній змінній *n з вбудованої функції *fibonacci(n,cache = {}) для обрахунку.
         
         *Примітка : Глобальноий простір коду(*Global Scope) - тіло коду поза описом функції оператором *def...\
                     Локальний простір коду(*Local Scope) - тіло коду в середені функції описаної оператором *def...  '''
         
    def fibonacci(n, cache = {}):
        '''Вбудована рекурсивна функція, яка приймає два аргументи:
                     # *n(тип *int)- обовязковий (передається з глобального простору, читай опис функ *caching_fibonacci(),
                     # *cache(тип *dict) - необовязковий (він є необовязковий бо відразу оголошено його початкове значення *{}. в локалному просторі буде набувати динамічного значення,  оскльки будемо його постійно формувати і рекурсивно повертати з функції, до поки не виконається умова *if fibon_new is not None  )
                     
                     # Повертає значення переданого в *n номера, числа Фібончі. # Приклад : *n = 9 , поверне зачення *34, *n = 4 , поверне зачення *3.
        # Опис алгоритму повернення : # Як тільки умова виконається *if fibon_new is not None: - виконається , відбудиться вихід з функції , а отже і припинеться рекурсія. і в *cache буде міститись згенерований словник з потрібним нам значенням .
                                      # значення на якому виконалось умова виходу з рекурісії , отримає ключ з поточним іменем *n в динамічно сформованому словнику *cache .
                                      # за поточним  значенням ключа *n повертаємо з функції його значення з динамічно створеного поточного словника *cache
                                      # Передане значення повернеться в глобалний простір як результат виконання функції за викликом *call_local_func_fibonacci(num_fibon) - для нашого прикладу.
                                      # Примітка : Поточні значення *n і *cache будуть міститися в локальному просторі *fibonacci '''
       
        fibon_new = cache.get(n) # За поточним значенням ключа *n, повертаємо відповідне значення з словника *cache. # Початкове поточне значення передається з глобального простору через зміну *num_fibon 
                                 # Для нашого прикладу *num_fibon = 9 отже в *n початково дорівнює *9.  
                                 # Осікільки початкове значення *cache = {}, оголошене як аргумент функції *fibonacci(n, cache = {}), дорівнює пустому словнику *{},
                                 # То такого ключа небуде в *cache і застосований метод  *cache.get(n) поверне значення *None на поточній ітерації функції. 
                                 # Примітка : # *cache.get(n) буде повертати *None до тих пір, поки в *cache не згенерується відповідний, переданий *n ключ, з відповідним значенням числа Фібоначі.
                                              # а отже буде відбуватись подальший код в тілі функції, оскільки подальший код буде містити рекуривний виклик поточної функції, 
                                              # то він буде виконуватись доти, поки n не стане 0 , зменшенням *n на одиницю на кожному рекурсивному виклику. # *n = n -1
       
        #print(f'fibon_new={fibon_new}') # тестовий принт для контролю значень.
        if fibon_new is not None : return fibon_new  # Запис умови для виходу з фукції *fibonacci(n, cache = {}) і повернення з функції кінцевого результату  *fibon_new.
                                                     # Примітка : Такий запис рахується більш бажаним і елегантінішим  рівноціному : 
                                                                                                                       # *if fibon_new != None :
                                                                                                                       #     return fibon_new  

        else :  # Допоки умова *if fibon_new is not None невиконується будемо генерувати нові значення в *cache  через рекурсивний виклик *cache[f'{n}'] = fibonacci(n-1) + fibonacci(n-2)
            
            if  n==0:   # Точка виходу з рекурсії .
                    return 0
            elif n==1 or  n==2 : # У мова досягнення точки виходу з рекурсії. Оскільки перше і друге число Фібоначі є одинаковими та дорівнює 1 # Примітка : пояснення для себе ))).
                    return 1
            else:
                cache[f'{n}'] = fibonacci(n-1) + fibonacci(n-2)  # Поки не виконаються умови *if  n==0: або *elif n==1 or  n==2 : ,точки виходу з рекурсії.
                                                                 # Будемо формувати наш словник *cache[f'{n}'] = fibonacci(n-1) + fibonacci(n-2) .
                                                                 # Де *[f'{n}'] - поточний ключ(на перошому кроці буде сформовано той, що і переданий у функцію з зміної *n = num_fibon , на наступному *(n - 1) , 
                                                                 # і так поки не стане *n = 3, *n = 3 це точка виходу з рекурсивного виклику , описана в умовами вище).
                                                                 # Як тільки рекурсивний виклик досягне точки виходу , то рекурсія почне схлопуватись в зворотньому порядку 
                                                                 # і на виході поверне наш наш динамічно створений *cache на останю ітерацію функції *fibonacci(n, cache = {}),
                                                                 # тоді *fibon_new = cache.get(n) поерне в *fibon_new відповідне значення, а не *None (осклільки наш *cache буде вже містити потрібну пару ключа і значення )
                                                                 # тоді і виконається умова *if fibon_new is not None : return fibon_new 
                                                                 # відповідно *call_local_func_fibonacci(num_fibon) , поверне відповідне число Фбоначі яке відповідає номеру переданому з *num_fibon 
                                                                 
                #print(cache) # тестовий принт для контролю значень
                #print(n)    # тестовий принт для контролю значень
                #print (cache[f'{n}']) #тестовий принт для контролю значень 
                
                return cache[f'{n}']  # Рекурсивне повернення в функцію поточного значення. за поточним ключем *[f'{n}'] для формування динамічного словника *cache
            
    print(fibonacci)
    return fibonacci # Повернення з основної функції *caching_fibonacci() імя вбудованої(*fibonacci)- імя містить локальний простір функції fibonacci(n, cache = {}) #  . 
                     # для того щоб забезпечити передачу, з глобального простору, значення *n з зміної *num_fibon ,
                     # у вбудовану функцію, в якій *n наперед не оголошено і відповіддний обрахунок та повернення відповідного значення числа Фібоначі для *num_fibon
                     # *fibonacci= <function caching_fibonacci.<locals>.fibonacci at 0x000002316BC27F60 - локальний простір *fibonacci(n, cache = {})
# +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

call_local_func_fibonacci = caching_fibonacci() # В *call_local_func_fibonacci повертаємо локальний простір *caching_fibonacci() з якого повертаємо імя вібудованої функції *fibonacci

num_fibon = 9 # тестове значення (вказує на номер чила Фібоначі значення якого потрібно обчислити і повернут)

#print(call_local_func_fibonacci) # Тестовий прінт.
print(call_local_func_fibonacci(num_fibon)) # тестовий прінт в якому і будемо робити виклик *call_local_func_fibonacci(num_fibon) з аргументом *num_fibon і одночас виводом на екран відповідого значення.
                                            # Для *num_fibon = 9 виведе 34 .


