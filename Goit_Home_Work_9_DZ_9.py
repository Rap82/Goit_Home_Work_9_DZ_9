# ===================  Home work 9 ========================

# =================    Функції (декоратори, замикання)  =================

    # 1. Функція як об'єкт першого класу
    # 2. Області видимості (LEGB)
    # 3. ЗАМИКАННЯ
    # 4.  КАРРУВАННЯ
    # 5. Декоратори
    # 6. Ітератори/генератори (ключове слово yield)
    # 7. Лямбда-функції (анонімні функції)
    # 8. MAP
    # 9. Filter

# ================================================================


# ================================ Звдання 1 / Task 1 ======================================

# ================================ Функція як обєкт першого класу . Виклик функції з іншої функції. =================================

# Wikipedia

# У програмуванні функція, яка приймає як аргументи інші функції або повертає іншу функцію в якості результату.
# Основна ідея у тому, що функції мають той самий статус, як і інші об'єкти даних.

# Оскільки у Python функції – це об'єкти першого класу, то вони є HOF (High Order Functions), 
# ця властивість активно використовується для розробки програмного забезпечення.

# На практиці це означає, що ми можемо працювати з функціями у Python точно так, як з будь-якими іншими типами даних:

# можемо створювати змінні і записувати в них функції;

#   def func(x, y):
#       return x + y

#   func_alias = func
#   result = func_alias(2, 3)
#   print(result)  # 5
# можемо передавати функцію як аргументи для інших функцій;

#   def sum_func(x, y):
#       return x + y

#   def subtraction_func(x, y):
#       return x - y

#   def tricky_func(x, y, func):
#       return func(x, y)

#   sum_result = tricky_func(2, 3, sum_func)
#   min_result = tricky_func(2, 3, subtraction_func)

#   print(sum_result)  # 5
#   print(min_result)  # -1
# можемо повертати з функції інші функції.

#   def sum_func(x, y):
#       return x + y

#   def subtraction_func(x, y):
#       return x - y

#   def get_operator(operator):
#       if operator == '+':
#           return sum_func
#       elif operator == '-':
#           return subtraction_func
#       else:
#           print('Unknown operator')

#   sum_action_function = get_operator("+")
#   print(sum_action_function(2, 3))    # 5

#   sub_action_function = get_operator("-")
#   print(sub_action_function(2, 3))    # -1
# Таким чином з функціями у Python можна працювати так само, як і з будь-якими іншими об'єктами.


# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++

# Повернемося до завдання про систему оцінок в університеті, які мають такий вигляд:

# Оцінка	Бали	Оцінка ECTS	    Пояснення

# 1	    0-34	    F	       Unsatisfactorily
# 2	    35-59	    FX	       Unsatisfactorily
# 3	    60-66	    E	       Enough
# 3	    67-74	    D	       Satisfactorily
# 4	    75-89	    C	       Good
# 5	    90-95	    В	       Very good
# 5	    96-100	    A	       Perfectly

# Минулого разу ми реалізували дві функції. Перша - get_grade, 
# приймає ключ в оцінці ECTS і повертає відповідну п'ятибальну оцінку (перший стовпчик таблиці).
# Друга - get_description, теж приймає ключ у оцінки ECTS, але повертає пояснення оцінки у текстовому форматі (останній стовпчик таблиці).
# На неіснуючий ключ функції повинні повертати значення None.

# Реалізуйте функцію вищого порядку get_student_grade, яка приймає параметр option. Якщо він дорівнює значенням "grade", 
# то функція повертає функцію get_grade, а якщо його значення дорівнює "description", то повертає функцію get_description. 
# Якщо параметр за значенням не співпав із заданими, то функція get_student_grade повинна повертати значення None.

# ++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

# def get_grade(key):
#     ''' Функція за ключем *key , повертає значення з словника *grade.\
#         якщо вказати невіриний ключ поверне заначення *None.'''
# 
#     grade = {"A": 5, "B": 5, "C": 4, "D": 3, "E": 3, "FX": 2, "F": 1}
#     return grade.get(key, None)


# def get_description(key):
#     ''' Функція за ключем *key , повертає значення з словника *description.\
#         якщо вказати невіриний ключ поверне заначення *None.'''
# 
#     description = {
#         "A": "Perfectly",
#         "B": "Very good",
#         "C": "Good",
#         "D": "Satisfactorily",
#         "E": "Enough",
#         "FX": "Unsatisfactorily",
#         "F": "Unsatisfactorily",
#     }
#     return description.get(key, None)

# def get_student_grade(option):
#     '''Функція приймає один аргумент *option, і якщо він містить змінні *get_description або *get_grade, \
#     то повертає відповідні функції за іменем оголошених функції після  оператора def *імя_функції(*аргументи_або_без_аргументів).\
#         Якщо аргументи, в оголошених функціях, відсутні в тілі коду обо повертати з основної функції тільки імя додаькової функції,\
#               то повертає клас *<function *імя_функції at *область_памяті_OS> на який вказує *optionю \
#                 Якщо аргумент оголошений в коді, і, в основновній функції повертає фінкцію, а не тільки їмя, то поверне результат отриманий з додаткової функції '''
 
#     if option == get_description: # Перевірка чи *option = get_description
#         return get_description    # якщо виконалась умова *if option == get_description - поверне *<function get_description at 0x000001B3B7327F60>
    
#     elif option == get_grade:     # Перевірка чи *option = get_grade
#         return get_grade          # якщо виконалась умова *elif option == get_grade - поверне *<function get_grade at 0x000001CB0CBF8A40>
#     else:
#        return None                # Поверне *None якщо жодна з попередніх умов невиконається .


# # key = "A" # Тестове значення.    
# # option = get_description # Тестове значення  # *<function get_description at 0x000001B3B7327F60>
# # option = get_grade  # Тестове значення  #  *<function get_grade at 0x000001CB0CBF8A40>
# # option = "asd"  # Тестове значення # *None

# # print(get_student_grade(option)) 

# +++++++++++++++++++++++ Для автоперевіки Код буде наступний +++++++++++++++++

# def get_student_grade(option):
    
#    if option == "description":
       
#        return get_description
   
#    elif option == "grade": 
#        return get_grade
#    else:
#        return None
   
# ================================ Звдання 2 / Task 2 ======================================

# ================================  Область видимості . Global Scope , Local Scope  =================================

# Область видимості — це область у програмі (коді), в межах якої ви можете звернутися по імені до вмісту змінної 
# (або як ми вже з'ясували функції). У Python можна виділити дві великі області видимості:

# глобальну (Global Scope). Все, що оголошено в цій області, буде доступне в будь-якій частині вашого додатку;
# локальну (Local Scope). Все, що оголошено в локальній області видимості, буде доступно тільки всередині неї.
# Глобальна область видимості лише одна і в ній міститься все, що ви оголосили на рівні модулю (змінні, функції, інші модулі і т.п).

# Локальна область видимості створюється, коли інтерпретатор потрапляє усередину функції.

# SOME_VAR = 3


# def func(x):
#     SOME_VAR = x
#     print(SOME_VAR)


# def procedure()
#     print(SOME_VAR)


# procedure()  # 3
# func(5)  # 5
# print(SOME_VAR)  # 3
# Давайте розберемо на цьому прикладі, як працюють області видимості. Змінна SOME_VAR оголошена на рівні модулю у глобальній області видимості 
# (так само, як і функції func та procedure).

# Коли ми викликаємо procedure усередині неї створюється локальна зона видимості. 
# У локальній для procedure області видимості немає SOME_VAR, і коли ми виконуємо вираз print(SOME_VAR), 
# Python спочатку шукає SOME_VAR у локальній області видимості, не знаходить і йде шукати у глобальній, де і знаходить SOME_VAR рівне 3.

# Коли ми викликаємо func, усередині неї створюється локальна зона видимості.
# В цій локальній області ми створюємо змінну SOME_VAR і привласнюємо їй значення 5.
# У цей момент глобальна зона видимості ніяк не змінюється, нова SOME_VAR існує тільки всередині func. 
# На підтвердження цього ми виконуємо print(SOME_VAR) на рівні модуля і отримуємо 3, що каже про те, 
# що всередині func існувала своя окрема змінна з ім'ям SOME_VAR.

# Щоб краще розуміти, що таке зона видимості, слід зрозуміти як працює їх механіка.

# У Python області видимості реалізовані як словники, в яких ім'я змінної або функції (рядок) — це ключ, 
# а сам об'єкт — це значення в цьому словнику.

# Таким чином, коли ви у коді виконали x = 2, в словнику простору імен (той же, що і область видимості) додалася пара: 'x': 2. 
# І коли десь далі вам потрібно отримати значення x із цього словника, буде взято значення 2, знайдене по ключу 'x'.

# Коли створюється нова зона видимості (простір імен), то насправді створюється новий подібний словник 
# (старий нікуди не дівається звичайно ж).

# Тут можна зробити важливий висновок, у вас в коді може одночасно існувати декілька просторів імен, які не взаємодіють один з одним. 
# Це у свою чергу означає, що пошук об'єктів по імені повинен відбуватися за якимсь правилом.

# У Python правила пошуку імен дуже прості:

# спочатку пошук йде в локальному просторі імен (LOCAL);
# якщо не знайдено в локальному, то в локальному на наступному рівні (ENCLOSED) і так далі, поки локальні не закінчаться;
# далі буде перевірено глобальний (GLOBAL) простір імен (рівень модуля);
# і в останню чергу простір вбудованих імен (BUILT INS) — це ключові слова і функції, що є частиною мови Python.
# Якщо ніде не знайдено сутності з таким ім'ям, то отримаємо виключення.

# Це правило можна запам'ятати по його акроніму: (LOCAL, ENCLOSED, GLOBAL, BUILT INS).

# У цьому правилі ми не розглянули, що таке ENCLOSED.

# GLOBAL_SCOPE_VAR = 1

# def func():
#     enclosed_scope_var = 2

#     def inner():
#         inner_var = 3
# В цьому коді всередині функції func оголошена функція inner. 
# Для функції func enclosed_scope_var та inner — знаходиться в LOCAL області видимості. 
# Для функції inner змінна inner_var буде в її локальній області видимості, 
# а вже enclosed_scope_var буде в ENCLOSED, в локальному просторі, але на рівень вище.

# ++++++++++++++++++++++++++++++++++++++Умова / Condition ++++++++++++++++++++++++++++++++++++++++


# Реалізуйте функцію get_discount_price_customer для розрахунку ціни на товар інтернет-магазину з урахуванням знижки клієнта.

# Функція приймає два параметри:

# price — ціна продукту
# customer — словник з даними клієнта такого виду: {"name": "Dima"} або {"name": "Boris", "discount": 0.15}
# Ви маєте глобальну змінну DEFAULT_DISCOUNT, яка визначає знижку для клієнта, якщо у нього немає поля discount.

# Функція get_discount_price_customer має повертати нову ціну товару для клієнта.

# Нагадаємо, що дисконт discount - це дробове число від 0 до 1. І ми під знижкою розуміємо коефіцієнт, який визначає величину ціни. 
# І на цю величину ми знижуємо підсумкову ціну товару: price = price * (1 - discount).

# +++++++++++++++++++++++++++++++++++ Код / Code ++++++++++++++++++++++++++++++++++++

DEFAULT_DISCOUNT = 0.05 # Глобальна константа( зміна )


def get_discount_price_customer(price, customer):
    '''Функція яка приймає два аргумента, 
     *price(тип *int) і *customer(тип *dict).
     Повертає *product_price(тип *float) - вартість товару з врахуванням знижки'''
    
    disc = customer.get("discount")  # *customer.get("discount") - повертаємо в *disc, значення з *customer, за ключем *"discount" методом -*.get(*key)
                                     # Метод *імя_словника.get("*ключ") - за вказаним ключем повертає з словника відповідне значення. 
                                     # Якщо вказаного ключа не має в словнику то повертає *None 
    
    if disc != None:                        # Умова для перевірки за значеням  *disc .Якщо значення не *None, значить в поточному словнику є ключ *"discount" 
                                            # Тобто в даного користувача є персональна знижка . Варість розраховуємо з врахуванням пересональної знижки. 
        product_price = price * (1-disc)    # Формула розрахунку вартості товару з урахуванням персональної знижки. *product_price = 100*(1-0.15)
        return product_price                # Тестове повернення: *product_price = 85
    
    else:                                   # Якщо умова не виконалась, тобто в *customer не має ключа *"discount". Розраховуємо вартсть товару з врахуванням загальної знижки *DEFAULT_DISCOUNT
        product_price = price * (1-DEFAULT_DISCOUNT) # Формула розрахунку вартості товару з урахуванням загальної знижки. *product_price = 100*(1-0.05)
        return product_price                # # Тестове повернення: *product_price = 95
    




price = 100  # Тестове значення

customer = {"name": "Dima"}  # Тестове занчення що немістить ключа *"discount"

customer = {"name": "Boris", "discount": 0.15} # # Тестове занчення що містить ключ *"discount"

print(get_discount_price_customer(price, customer)) # Принтимо значення яке поверне функція *get_discount_price_customer(price, customer)




  

